# Swift

### 스위프트 언어의 특징

- 빠름(Fast)

   - 복합정렬 벤치마크를 보면 파이썬보다 대략 3.9배 빠름, Objc보다 약 2.8배 빠름

   - LLVM 컴파일러에서 제공하는 코드 최적화기를 사용해 소스 컴파일과 최적화를 수행

- 설계에 의한 안정성(Safety by Design)

   - 변수나 상수는 반드시 선언한 후에 사용하도록 강제

   - 타입 추론 기능에 의해 변수의 초기값을 기준으로 타입 정의

   - 배열과 정수는 오버플로우에 대비하여 확인

   - 개발자가 정의하지 않은 배열 값에 승인하지 않은 값들이 주입될 수 없도록 Array bounds check

   - 포인터에 직접 접근하는 시도 차단, 클래스를 통해 간접적으로만 레퍼런스 참조하도록 제한

   - ARC를 이용해 자동으로 메모리 관리

- 현대적(Modern)

   - 파이썬 언어에 기반을 둔 읽고 쓰기 쉬운 문법

   - 헤더 파일 사용 대신 메인 파일에 통합하여 코드 작성

- 상호반응(Interactive)

- 완전한 플랫폼(Complete Platform)

   - Objc 코드에 의존하지 않고도 프로그램 작성 가능

- 통합(Unified)

<br />

### 스위프트의 기초 문법 특징

- 헤더 파일을 작성할 필요가 없다.

   - 기존의 Objc는 헤더 파일과 메인 파일로 분리되어 있었지만, 스위프트는 헤더와 소스 파일이 통합된 하나의 *.swift 파일에 필요한 내용을 자유롭게 정의하고 사용

- 대소문자 구분

- 구문 끝의 세미콜론은 생략 가능

   - 한 줄에 두 개 이상의 구문을 작성할 때는 세미콜론을 붙여야 함

- 엔트리 포인트(시작점)으로 사용되는 main() 함수가 없음

   - 다만, @UIApplication 어노테이션을 사용해 앱을 시작하는 객체 지정

- String 뿐만 아니라 Character도 큰 따옴표 사용

- import 키워드를 사용하지만, 라이브러리와 프레임워크의 참조 용도

- C나 자바처럼 한 줄 주석, 여러 줄 주석 처리 방식을 모두 지원

   - // : 한 줄 주석

   - /* ~ */ : 여러 줄 주석

- try ~ catch 방식의 오류 처리 지원

<br />

### 변수와 상수

- 저장한, 혹은 저장할 메모리 주소값을 이름으로 연결해 놓은 것

- 둘 다 값을 저장할 수 있지만 상수는 한 번 저장된 값을 다른 값으로 변경할 수 없음

- 변수의 값을 변경할 수 있다고 하더라도 처음 저장했던 값과 일치하는 타입으로만 변경 가능

- 스위프트는 '타입 추론기'라는 기능 모듈을 컴파일러에 별도로 내장하여, 항상 최적의 타입을 결정

- 변수명, 상수명 정의

   - 알파벳과 한글 자음 및 모음, 아라비아 숫자, 특수 기호, 한자, 이미지용 바이너리 코드 모두 사용 가능 → 사용할 수 있다의 정도지 영어, 숫자, 밑줄 이외의 다른 문자나 기호 절대 쓰지 말것

   - 연산자와 혼동할 수 있는 +, -, *, / 및 공백은 사용할 수 없음(언더바는 가능)

   - 예약어나 키워드로 등록되어 있는 단어 사용 불가능. 단, 대소문자 변경 시 사용 가능

   - 첫 번째 자리에 숫자는 올 수 없음

### 기본 자료형(Data Types)

- Int

   - Int8, Int16, Int32, Int64 등으로 이어지는 int 계열 서브 자료형의 대표 자료형

   - 부호 있느 정수 자료형

   - 해당 컴퓨터의 CPU 비트 크기에 맞춰 자동으로 그 크기 변화

- UInt

   - 부호 없는 정수, 양수만 저장 가능

- Double & Float

   - 실수 값을 저장할 수 있는 자료형

   - Double : 64비트 부동 소수점 자료형 (소수점 아래 15~16자리)

   - Float : 32비트 부동 소수점 자료형 (소수점 아래 7~8자리)

- Bool

   - true / false 두 값만 가질 수 있는 논리값을 저장하는 자료형

- String

   - 문자열을 저장할 수 있는 집단 자료형

   - NSString과 String 사이의 타입 변환은 오류 발생 여지가 없는 완전 변환

- Character

   - 한 개의 문자를 저장할 수 있는 단일 자료형

   - Character 타입의 데이터 값을 표현할 때도 큰 따옴표 사용

   <br />

### 타입 어노테이션(Type Annotation)

- 변수나 상수를 선언할 때 타입을 명시적으로 선언해주는 것

- 변수나 상수명 뒤에 콜론(:)을 붙여서 타입 지정

- ex) var year: Int?

### 타입 추론(Type inference)

- 변수나 상수를 초기화할 때 입력된 값을 분석하여 변수에 적절한 타입을 컴파일러가 스스로 추론하는 기능

- 주어진 값이 타입 A와 타입 B에 동시에 속하는 경우, 더 넓은 범위의 타입으로 결정

- 더 작은 범위의 타입으로 정의하려면 반드시 타입 어노테이션을 통해 명시적으로 선언해야 함

### 문자열 템플릿

- 문자열에 변수를 포함시킬 때 좀 더 직관적이고편하게 사용하기 위한 기능

- "문자열 \(변수)"처럼 \() 안에 변수명을 넣어서 사용

### 쿼우팅(Quoting)

- 문자열을 따옴표로 묶어서 표시하는 방법

- 스위프트에서는 문자열, 문자 모두 "(큰따옴표)로 표시

- 멀티 라인 스트링

   - 스위프트 4.0부터 도입된 문법

   - 큰따옴표 세 개를 연속으로 붙여(""" ~ """) 그 내부에서 자유롭게 작성된 문자열을 실제 내용으로 처리하는 방식

   - 트리플 쿼우팅(Triple-Quoting)이라고 불리기도 함

   - 트리플 쿼우팅이 시작된 후에는 줄바꿈 후 입력을 시작해야 하고, 종료할 때에도 줄바꿈하여 쿼우팅을 닫아야 함

   <br />

### 연산자

<br />

| 구분 | 연산자 | 사용 예 | 의미 |
 | --- | --- | --- | --- |
| 단항 연산자 | - | -a | 값의 부호 변경 |
| 이항 연산자 | + | a + b | 두 개의 값을 더함 |
|     | - | a - b | 앞의 값에서 뒤의 값을 뺌 |
|     | * | a * b | 두 개의 값을 곱함 |
|     | / | a / b | 앞의 값을 뒤의 값으로 나눔 |
|     | % | a % b | 앞의 값을 뒤의 값으로 나눈 나머지 |

<br />

| 연산자 | 사용 예 | 의미 |
 | --- | --- | --- |
| < | a < b | a가 b보다 작으면 true |
| > | a > b | a가 b보다 크면 true |
| <= | a <= b | a가 b보다 작거나 같으면 true |
| >= | a >= b | a가 b보다 크거나 같으면 true |
| == | a == b | a가 b와 같으면 true |
| != | a != b | a와 b가 다르면 true |

<br />

| 연산자 | 사용 예 | 의미 |
 | --- | --- | --- |
| ! | !a | a가 true면 false 반환, false면 true 반환 |
| && | a && b | a와 b 모두 true면 true 반환 하나라도 false면 false 반환 |
| || | a || b | a와 b 둘 중 하나라도 true면 true 반환 둘 다 false면 false 반환 |

#### 범위 연산자

- 닫힌 범위 연산자(Closed range operator)

   - 주어진 피연산자 a, b를 포함하는 범위를 나타내는 연산자

   - ex) 1...5 : 1부터 5까지의 범위

- 반 닫힌 범위 연산자(Half-closed range operator)

   - 연산자 양쪽 경계 중 왼쪽 경계는 포함하되 오른쪽 경계는 포함하지 않는 연산자

   - ex) 1..<5 : 1부터 4까지의 범위

- 범위 연산자의 왼쪽에는 작은 숫자, 오른쪽에는 그보다 큰 숫자를 배치해야 한다 그렇지 않다면 런타임 오류가 뜨기 때문에 주의해야 함

<br />

| 연산자 | 사용 예 | 의미 |
 | --- | --- | --- |
| = | a = 1 | 변수 a에 1을 대입 |
| += | a += 1 | a = a + 1 |
| -=  | a -= 1 | a = a - 1 |
| *= | a *= 2 | a = a * 2 |
| /= | a /= 3 | a = a / 3 |
| %= | a %= 3 | a = a % 3 |
| <<= | a <<= 3 | a = a << 3 |
| >>= | a >>= 3 | a = a >> 3 |
| &= | a &= b | a = a & b |
| ^= | a ^= b | a = a ^ b |
| |= | a |= b | a = a | b |

<br />

### 흐름 제어 구문

- 프로그램 실행 과정에서 실행 흐름을 능동적으로 제어하기 위한 목적으로 사용되는 구문

- 반복문 : 주어진 조건에 따라 특정 코드 블록을 반복적으로 실행

- 조건문 : 특정 조건이 성립할 경우 지정된 코드 블록이 실행되도록 제어

- 특정 지점의 코드로 실행 제어를 옮겨줌으로써 코드가 실행되는 순서를 제어

<br />

#### 반복문

- For 반복문

   - for <루프 상수> in <순회 대상> { <실행 구문> }

   - 순회 대상 데이터 타입

      - 배열

      - 딕셔너리

      - 집합

      - 범위 데이터

      - 문자열

   - 루프 상수 생략 가능 for _ in ~

- while 구문

   - while <조건식> { <실행 구문> }

   - 조건식을 만족하는 동안 계속 실행

- reepat ~ while 구문

   - repeat { 

         <실행 구문>

      }

      while <조건식>

   - 실행 구문의 수행을 최소 한 번 보장

   <br />

#### 조건문

- if 구문

   - if <조건식> { <실행 구문> }

   - 조건을 만족하면 코드 블록 실행

- guard 구문

   - guard <조건식 또는 표현식> else { <실행 구문> }

   - 결과가 false일 때 실행 구문 수행

   - 주로 후속 코드들이 실행되기 전 특정 조건을 만족하는지 확인하는 용도로 사용

   - 즉, 특정 조건을 만족하지 않은 채로 후속 코드를 실행하면 심각한 오류가 발생하는 경우, 전체 구문을 조기 종료하기 위한 목적으로 사용

- #available 구문

   - OS 버전과 기기를 체크하기 위한 구문

   - ex) if #available(iOS 9, OSX 10.10, watchOS 1, *) {}

- switch 구문

   - switch <비교 대상> {

         case <비교 패턴>:

         default:

      }

   - C나 자바와 문법이 유사하지만 C나 자바는 비교 패턴이 일치하는 경우 우선 실행 구문을 처리한 후 나머지 case에 대한 비교를 계속 진행하지만  스위프트는 일치하는 비교 패턴이 있을 경우 실행 코드 처리 후 전체 분기문 종료

   - 따라서 각 case 별로 break 구문 생략 가능

   - 암시적인 Fall Through 지원 X: 일치하는 case 블록을 실행하는 대신, 그 다음 case 블록으로 실행 흐름 전달

   - 대신 명시적으로 fallthrough 구문을 사용함으로써 Fall Through 지원

   - 스위프트에서는 case 키워드 다음에 하나 이상의 비교 패턴을 연이어 작성 가능

   - 튜플 내부의 아이템이 비교 대상과 부분적으로 일치하는 경우, 패턴 전체가 일치하는 것으로 간주

      ```swift
      var value = (2, 3)
      
      switch value {
      case let (x, 3):
      	print("튜플의 두 번째 값이 3일 때 첫 번째 값은 \(x)입니다")
      case let (3, y):
      	print("튜플의 첫 번째 값이 3일 때 두 번째 값은 \(y)입니다")
      case let (x, y):
      	print("튜플의 값은 각 \(x), \(y)입니다")
      }
      ```

   - 범위 연산자도 사용 가능

      ```swift
      var passtime = 1957
      
      switch passtime {
      case 0..<60:
      case 60..<3600:
      case 3600..<86400:
      default:
      }
      ```

   <br />

   #### 제어 전달문

   - break : switch 구문에서의 실행 흐름이나 반복 실행 중인 루프를 조건식의 결과와 상관 없이 즉각 종료

   - continue : 이 구문 아래에 있는 실행 구문들을 건너 뛰고 다음 반복을 시작

   <br />

   <br />

   ### 집단 자료형

   - 배열(Array) : 순서에 따라 데이터가 정렬된 목록 형태의 자료형

   - 집합(Set) : 중복되지 않은 유일 데이터들이 모인 집합 형태의 자료형

   - 튜플(Tuple) : 종류에 상관없이 데이터들을 모은 자료형, 수정 및 삭제 불가능

   - 딕셔너리(Dictionary) : 배열과 유사하나 인덱스 대신 키(Key)를 사용하여 Key-Value로 연관된 데이터들이 순서 없이 모인 자료형

   <br />

   #### 배열

   - 배열에 저장할 아이템의 타입에는 제약이 없지만, 하나의 배열에 저장하는 아이템의 타입은 모두 같아야 함

   - 선언 시 배열에 저장할 아이템 타입을 명확히 정의해야 함

   - 배열의 크기는 동적으로 확장할 수 있음

   #### 집합

   - 내부적으로 해시 연산의 결과값을 이용해 데이터를 저장하므로 데이터 타입은 해시 연산을 할 수 있는 타입이어야 함

   - 기본 타입이 아닌 임의로 만든 타입을 집합으로 사용하려면 Hashable 프로토콜을 구현해야 함

   - 기본 집합 연산

      - intersection(_:) : 양쪽 집합에서 공통되는 아이템을 선택해 새로운 집합을 만드는 메소드(교집합)

      - symmetricDifference(_:) : 양쪽 집합 중에서 한 쪽에만 있는 아이템을 선택하여 새로운 집합을 만드는 메소드, 양쪽 집합에 공통으로 있는 아이템은 제외

      - union(_:) : 양쪽 집합에 있는 모든 아이템을 선택하여 새로운 집합을 만드는 메소드(합집합)

      - subtract(_:) : 한쪽 집합에 있는 아이템에서 다른 쪽 집합에도 속하는 공통 아이템을 제외하고 새로운 집합을 만드는 메소드(차집합)

   - 부분집합과 포함관계 판단 연산

      - isSubset(of:) : 하나의 집합이 다른 집합의 부분집합인지 여부 판단

      - isSuperset(of:) : 하나의 집합이 다른 집합의 상위집합 역할을 하는지 판단

      - isDisjoint(with:) : 두 집합 사이의 공통 값이 없으면 true 하나라도 있으면 false

   #### 튜플

   - 여러 가지 타입의 아이템을 저장할 수 있지만, 선언되고 나면 상수적 성격을 띠므로 값을 추가하거나 삭제하는 등 변경 불가능

   - 하나의 아이템만 있는 튜플은 일반 자료형이 된다. ex) var tpl: (String) = ("tuple") == var tpl: String = "tuple"

   - 튜플의 아이템을 개별 변수나 상수로 각각 할당받는 바인딩 방식의 구문도 제공

   #### 딕셔너리

   - 고유 키(Key)와 그에 대응하는 값(Value)을 연결하여 데이터를 저장하는 자료형

   - 하나의 키는 하나의 데이터에만 연결

   - 키는 중복될 수 없음

   - 아이템에는 순서가 없지만 키에는 내부적으로 순서가 있으므로 for~in 구문으로 순회 탐색 가능

   - 키의 타입은 Hash 연산이 가능한 타입 즉, Hashable 프로토콜을 채택하고 구현한 타입

   <br />

   <br />

   <br />

### 옵셔널

- 값이 없음을 의미하는 특수한 값

- 언어 차원에서 프로그램의 안정성을 높이기 위해 사용

- Objc에서는 빈 메모리 주소를 가리키는 값이었지만 스위프트에서는 단순히 '값이 없음'을 의미

- 스위프트에서는 연산 과정에서 정상적으로 값을 처리하지 못하는 상황이 발생했을 때 오류 대신 nil을 반환

- 옵셔널 타입으로 선언된 자료형만 nil 값을 저장할 수 있음

- 옵셔널 타입 : 반환하고자 하는 값을 옵셔널 객체로 한번 더 감싼 형태 (옵셔널 래핑)

- 옵셔널 언래핑(Optional Unwrapping) : 옵셔널 타입을 해제하고 실제 값을 추출하는 것

<br />

#### 옵셔널 해제(Optional Unwrapping)

- 명시적 해제

   - 강제 해제

      - 옵셔널 타입의 값 뒤에 "!" 기호를 붙여주는 것, 강제 해제 연산자

      - 값이 nil인 경우 런타임 오류 발생

   - 비강제 해제

      - 옵셔널 바인딩 : if 구문 내에 조건식 대신 옵셔널 값을 일반 변수나 상수에 할당하는 구문을 사용하는 방식, guard 구문을 이용해도 옵셔널 바인딩 가능

         - if 구문을 사용한 옵셔널 바인딩 : if 구문의 코드 블럭 내에서만 해제된 값 사용 가능

         - guard 구문을 사용한 옵셔널 바인딩 : 실행 흐름 상 옵셔널 값이 해제되지 않으면 진행이 불가능할 정도로 큰일이 생길 때 사용하는 것이 좋음

- 묵시적 해제

   - 타입 어노테이션 뒤에 ? 대신 !를 붙여서 선언

   - 형식상 옵셔널로 정의해야 하지만, 실제로 사용할 때에는 절대 nil 값이 대입될 가능성이 없는 변수일 때 사용

<br />

<br />

## 함수

- 프로그램의 실행 과정 중에서 독립적으로 처리될 수 있는 부분을 분리하여 구조화한 객체

- 입력값을 받아 내부 처리 과정을 거친 후 그 결과값을 내어놓는 형태

- 일반 함수 : 프로그래밍 언어나 프레임워크 수준에서 제공하는 함수 (기본적으로 데이터의 처리나 연산 등을 수행하기 위한 목적)

- 사용자 정의 함수 : 우리가 원하는 기능을 실행해줄 함수를 직접 만들어 사용하는 함수

   ```swift
   func 함수이름(매개변수1: 타입, 매개변수2: 타입, ...) -> 반환타입 {
   	실행 내용
   	return 반환값
   }
   ```

- 인자 레이블 : 함수의 호출 시 인자값을 구분하기 위해 사용되는 레이블

- 외부 매개변수: 함수를 호출할 때 인자값에 대한 레이블 역할 및 함수의 식별자 일부로 사용

- 내부 매개변수 : 입력된 인자값을 함수 내부에서 참조하기 위해 사용되는 변수

   ```swift
   func 함수이름(<외부 매개변수명> <내부 매개변수명>: <타입>, ...) -> 반환타입 {
   	//함수 내용
   }
   ```

- 가변 인자 : 인자값의 입력 개수를 제한하지 않도록 하는 인자, ...로 표시 (함수 내부에서 배열로 처리)

   ```swift
   func 함수이름(매개변수명: 매개변수타입 ...)
   ```

- 기본값을 갖는 매개변수

   ```swift
   func 함수이름(매개변수: 매개변수타입 = 기본값)
   ```

- 스위프트에서 매개변수는 상수로 정의되기 때문에 함수 내에서 수정 불가능

   - 아래와 같이 변수화하여 수정할 수 있도록 가능

   ```swift
   func incrementBy(base: Int) -> Int {
       var base = base
       base += 1
       return base
   }
   ```

- inout 매개변수 : 함수 내부에서 수정된 인자값을 함수 외부에 전달할 수 있도록 하는 키워드

   ```swift
   func foo(paramCount: inout Int) -> Int {
       paramCount += 1
       return paramCount
   }
   ```

   - 함수 호출 시 인자값 앞에 & 연산자를 붙여주어야 한다.

   - 정확한 의미는 값이 저장된 메모리 주소를 전달한다는 의미(참조에 의한 전달)

   - 클래스는 항상 참조 전달이기 때문에 inout을 쓸 필요 없음

   - 상수, 리터럴은 inout 인자값으로 전달될 수 없음

- 스코프(Scope) : 변수의 생존 범위, 스위프트에서는 선언된 블록 내부

   - 변수가 생성된 블록이 아닌 다른 블록에서 사용하려면 반드시 초기화되어 있어야 한다

      - 하나의 블록 내에서 다른 블록으로 참조에 의한 전달 과정이 일어나기 때문이다

      - 변수가 초기화되지 않았다면 메모리를 할당받지 못한 상태이므로 주소값도 존재하지 않는다

   - 블록변 변수 검색 순서

      - 함수 내부에서 정의된 변수를 찾음

      - 함수 외부에서 정의된 변수를 찾음

      - 글로벌 범위에서 정의된 변수를 찾음

      - import 된 라이브러리 범위에서 정의된 변수를 찾음

<br />

#### 일급 객체로서의 함수

- 일급 함수의 특성

   - 객체가 런타임에도 생성이 가능해야 한다

   - 인자값으로 전달할 수 있어야 한다

   - 반환값으로 사용할 수 있어야 한다

   - 변수나 데이터 구조 안에 저장할 수 있어야 한다

   - 할당에 사용된 이름과 관계 없이 고유한 구별이 가능해야 한다

1. 변수나 상수에 함수를 대입할 수 있음

   ```swift
   func foo(base: Int) -> String {
       return "결과값은 \(base + 1)입니다"
   }
   
   let fn1 = foo(base: 5)
   ```

   - 위는 함수의 결과값을 fn1이라는 상수에 할당하는 단순한 대입 연산

   ```swift
   func foo(base: Int) -> String {
       return "결과값은 \(base + 1)입니다"
   }
   
   let fn2 = foo
   
   print(fn2(5))
   ```

   - 위 코드가 상수 fn2에 foo 함수를 대입하는 것

   - 함수 타입 : 함수의 형태를 축약한 형태로 사용 (인자 타입1, 인자 타입2, ...) → 반환 타입

   ```swift
   func boo(age: Int) -> String {
   	return "\(age)"
   }
   ```

   <br />

      - boo - 함수의 이름

      - boo(age:) - 함수의 식별자

1. 함수의 반환 타입으로 함수를 사용할 수 있음

   ```swift
   func desc() -> String {
   	return "this is desc()"
   }
   
   func pass() -> () -> String {
   	return desc
   }
   
   let p = pass()
   
   p()
   ```

   - pass의 리턴값은 () → String 타입의 함수

   - pass의 반환값으로 desc함수가 반환

   - 상수 p에 pass의 반환값을 담음 ⇒ desc 함수가 p에 담김

   - p에 함수 호출 연산자를 붙여 실행하면 desc 함수가 실행됨

1. 함수의 인자값으로 함수를 사용할 수 있음

   - 예

   ```swift
   func incr(param: Int) -> Int {
       return param + 1
   }
   
   func broker(base: Int, function fn: (Int) -> Int) -> Int {
       return fn(base)
   }
   
   broker(base: 3, function: incr) // 4
   ```

   - 콜백 함수 사용하는 예

   ```swift
   func successThrough() {
       print("연산 처리 성공")
   }
   
   func failThrough() {
       print("연산 처리 실패")
   }
   
   func divide(base: Int, success sCallBack: () -> Void, fail fCallBack: () -> Void) -> Int {
       guard base != 0 else {
           fCallBack()
           return 0
       }
       
       defer {
           sCallBack()
       }
       
       return 100 / base
   }
   
   divide(base: 3, success: successThrough, fail: failThrough)
   ```

   - defer : 함수나 메소드에서 코드의 흐름과 상관없이 가장 마지막에 실행되는 블록 

      - 작성된 위치와 순서에 상관없이 함수가 종료되기 직전에 실행

      - defer 블록을 읽기 전에 함수의 실행이 종료되는 경우 defer 블록은 실행되지 않는다

      - 하나의 함수나 메소드 내에 defer 블록을 여러 번 사용할 수 있다. 이 때에는 가장 마지막에 작성된 defer 블록부터 역순으로 실행

      - defer 블록을 중첩해서 사용할 수 있다. 이 때에는 가장 바깥쪽 defer부터 안쪽 defer 순서로 실행된다

   - 함수를 인자로 넘기는 가장 큰 목적은 함수 내부의 코드를 건드리지 않고도 외부에서 실행 흐름을 추가하기 위함

<br />

#### 함수의 중첩

- 스위프트에서는 함수를 중첩해서 작성할 수 있다

- 이렇게 작성된 함수를 **중첩 함수**라고 한다

- __내부 함수(Nested Function)__ : 함수 내에 작성된 함수

- __외부 함수(Outer Function)__ : 내부 함수를 포함하는 바깥 쪽 함수

- __내부 함수의 생명 주기(Life Cycle)__ : 외부 함수가 종료되면 내부 함수도 종료

- **함수의 은닉성 :** 내부 함수는 일반적으로 외부 함수를 거치지 않으면 접근할 수 없다 이 때문에 내부 함수는 외부의 코드로부터 차단되는 결과를 가져옴

   ```swift
   func outer(param: Int) -> (Int) -> String {
       func inner(inc: Int) -> String {
           return "\(inc)를 리턴"
       }
       
       return inner
   }
   ```

- 하지만 위처럼 외부 함수에서 내부 함수를 반환하면 외부 함수가 종료되더라도 내부 함수의 생명은 유지됨

```swift
func basic(param: Int) -> (Int) -> Int {
    let value = param + 20
    
    func append(add: Int) -> Int {
        return value + add
    }
    
    return append
}

let result = basic(param: 10) // append(10)
result(10)  // 40
```

- 위처럼 result 상수에는 append 함수가 담기고 append 함수는 외부 함수의 value 상수를 참조한다.

- result를 실행할 때에 basic 함수는 종료되어 value도 같이 사라져 오류를 발생할 것이라 예상할 수 있지만 이 코드는 문제 없이 동작하여, 40이라는 결과를 반환한다.

- 이러한 현상에 대한 원인은 **append 함수가 클로저를 갖기 때문**이다.

#### 클로저

- 소프트웨어 아키텍쳐적인 개념

   - 클로저는 두 가지로 이뤄진 객체이다. 하나는 내부 함수이며, 또 다른 하나는 내부 함수가 만들어진 주변 환경

   - 클로저는 외부 함수 내에서 내부 함수를 반환하고, 내부 함수가 외부 함수의 지역 변수나 상수를 참조할 때 만들어진다

   - 즉, 클로저란 __내부 함수와 내부 함수에 영향을 미치는 주변 환경(Context)를 모두 포함한 객체이다.__

   - 주변 환경 : 내부 함수에서 참조하는 모든 외부 변수나 상수의 값, 그리고 내부 함수에서 참조하는 다른 객체

   - 클로저는 주변 환경을 포함하지만, 주변 환경의 객체 자체를 포함하는 것이 아니라 값을 포함한다

   - 지역 변수의 값이 저장되는 것을 "값이 캡처되었다" 라고 표현한다

- 스위프트에서의 클로저

   - 일회용 함수를 작성할 수 있는 구문

   - __익명(Anonymous) 함수__ 라고 부르기도 함

   - 스위프트에서 클로저라고 부르는 객체는 대부분 다음 세 가지 경우 중 하나에 해당

      1. 전역 함수 : 이름이 있으며, 주변 환경에서 캡처할 어떤 값도 없는 클로저

      1. 중첩 함수 : 이름이 있으며 자신을 둘러싼 함수로부터 값을 캡처할 수 있는 클로저

      1. 클로저 표현식 : 이름이 없으며 주변 환경으로부터 값을 캡처할 수 있는 경량 문법으로 작성된 클로저

   - 스위프트에서 클로저는 참조 형식이다

   - 클로저는 외부에 선언되어 있는 변수를 클로저 내부에서 사용할 때 값을 캡처

   - 캡처한 값은 대상의 사용 범위에 관계 없이 클로저가 실행되는 동안 메모리에 유지

   - 클로저는 값을 캡처할 때 참조 전달

   - 클로저가 값을 캡처할 때 발생할 수 있는 retain cycle 문제는 약한 참조와 클로저 캡처 목록을 통해 해결할 수 있음

<br />

#### 클로저 표현식

```swift
{ (매개 변수) -> 반환 타입 in
	실행 구문
}
```

#### 트레일링 클로저(Trailing Closure)

- 함수의 마지막 인자값이 클로저일 때, 이를 인자값 형식으로 작성하는 대신 함수의 뒤에 꼬리처럼 붙일 수 있는 문법

#### @escaping

- 인자값으로 전달된 클로저를 저장해 두었다가, 나중에 다른 곳에서도 실행할 수 있도록 혀용해주는 속성

- 스위프트에서 함수의 인자값으로 전달된 클로저는 기본적으로 **탈출불가(non-escape)**의 성격을 띔

   - 함수 내에서 직접 실행을 위해서만 사용해야 한다는 의미

   - 함수 내부라 하더라도, 변수나 상수에 대입할 수 없음

   - 또한 인자값으로 전달된 클로저는 중첩된 내부 함수에서 사용할 수도 없다 

- 클로저의 기본 속성을 탈출불가하게 관리함으로써 얻는 이점

   - 컴파일러가 코드를 최적화하는 과정에서의 성능 향상 (컴파일러가 더 이상 메모리 관리 상의 지저분한 일들에 관여할 필요가 사라지기 때문)

   - 탈출불가 클로저 내에서는 self 키워드를 사용할 수 있다. 이 클로저는 해당 함수가 끝나서 리턴되기 전에 호출될 것이 명확하기 때문

<br />

#### @autoclosure

- 인자값으로 전달된 일반 구문이나 함수 등을 클로저로 래핑하는 역할

   ```swift
   func condition(stmt: @autoclosure () -> Bool) {
       if stmt() == true {
           print("결과가 참입니다.")
       } else {
           print("결과가 거짓입니다.")
       }
   }
   
   //실행 방법
   condition(stmt: (4 > 2)
   ```

- @autoclosure 속성이 인자값에 부여되면 해당 인자값은 컴파일러에 의해 클로저로 자동 래핑된다

- 함수를 실행할 때에는 {} 형식의 클로저가 아닌 () 형식의 일반값을 인자값으로 사용한다

- 인자값은 코드에 작성된 시점이 아니라 해당 클로저가 실행되는 시점에 맞춰 실행 (__지연 실행__)

<br />

<br />

### 구조체와 클래스

- **프로퍼티(Property)** : 구조체와 클래스 내부에서 정의된 변수와 상수

- __메소드(Method)__ : 구조체와 클래스 내부에서 정의된 함수

- __멤버(Member)__ : 프로퍼티와 메소드를 합한 명칭

- 공통점

   - 프로퍼티 : 변수나 상수를 사용하여 값을 저장하는 프로퍼티 정의 가능

   - 메소드 : 함수를 사용하여 기능을 제공하는 메소드 정의 가능

   - 서브스크립트 : 속성값에 접근할 수 있는 방법을 제공하는 서브스크립트 정의 가능

   - 초기화 블록 : 객체를 원하는 초기 상태로 설정해주는 초기화 블록 정의 가능

   - 확장 : 객체에 함수적 기능을 추가하는 확장(extends) 구문 사용 가능

   - 프로토콜 : 특정 형식의 함수적 표준을 제공하기 위한 프로토콜 구현 가능

- 차이점 (구조체는 할 수 없지만 클래스는 할 수 있는 것)

   - 상속 : 클래스의 특성을 다른 클래스에게 물려주는 것

   - 타입 캐스팅 : 실행 시 컴파일러가 클래스 인스턴스의 타입을 미리 파악하고 검사 가능

   - 소멸화 구문 : 인스턴스가 소멸되기 직전에 처리해야 할 구문 미리 등록 가능

   - 참조에 의한 전달 : 클래스 인스턴스는 참조 형식으로 제공

- struct와 class를 선택하기 위한 애플의 가이드라인 권장 사항

   - 연관된 간단한 값의 집합을 캡슐화하는 것이 목적일 때 구조체 사용

   - 캡슐화한 값을 참조하는 것보다 복사하는 것이 합당할 때 구조체 사용

   - 구조체에 저장된 프로퍼티가 값 타입이며 참조하는 것보다 복사하는 것이 합당할 때 구조체 사용

   - 다른 타입으로부터 상속받거나 모델의 사이즈가 그리 크지 않다면 구조체 사용

   - 해당 모델을 serialize 해서 전송가허나 파일로 저장할 경우가 발생하면 클래스 사용

   - 해당 모델이 ObjC 에서도 사용되어야 한다면 클래스 사용

   <br />

#### 프로퍼티

- 역할에 따른 분류

   - 저장 프로퍼티

      - 입력된 값을 저장하거나 저장된 값을 제공하는 역할

      - 상수 및 변수를 사용해서 정의 가능

      - 클래스와 구조체에서는 사용이 가능하지만, 열거형에서는 사용 불가

   - 연산 프로퍼티

      - 특정 연산을 통해 값을 만들어 제공하는 역할

      - 변수만 사용해서 정의 가능

      - 클래스, 구조체, 열거형에서 모두 사용 가능

- 소속에 따른 분류

   - 인스턴스 프로퍼티 : 인스턴스에 소속되는 프로퍼티

   - 타입 프로퍼티 : 클래스와 구조체 자체에 소속되어 값을 가지는 프로퍼티, 인스턴스를 생성하지 않고 클래스나 구조체 자체에 값을 저장하는 프로퍼티

   <br />

- 저장 프로퍼티

   - 클래스 내에서 선언된 변수나 상수를 부르는 이름

   - 멤버 변수 : var 키워드로 정의되는 변수형 저장 프로퍼티

   - 멤버 상수 : let 키워드로 정의되는 상수형 저장 프로퍼티

   - 지연 저장 프로퍼티 : 앞에 lazy 키워드가 붙으며 초기화를 지연시켜 프로퍼티가 호출되는 순간 초기화가 진행되는 프로퍼티

- 연산 프로퍼티

   - 실제 값을 저장했다가 반환하는 것이 아니고 다른 프로퍼티의 값을 연산 처리하여 간접적으로 값을 제공하는 프로퍼티

   - 이 때 프로퍼티의 값을 참조하기 위해 내부적으로 사용하는 구문이 get 구문

   - 읽기 전용 프로퍼티 (get-only 프로퍼티) : set구문이 없는 연산 프로퍼티

- 프로퍼티 옵저버 : 특정 프로퍼티를 관찰하고 있다가 프로퍼티의 값이 변경되면 호출되는 것

   - willSet : 프로퍼티의 값이 변경되기 직전에 호출

   - didSet : 프로퍼티의 값이 변경된 직후에 호출

- 타입 프로퍼티

   - 프로퍼티 앞에 static 키워드로 선언

   - class 키워드는 연산 프로퍼티에만 붙일 수 있는 타입 프로퍼티 키워드

   - class 키워드는 상속받은 하위 클래스에서 재정의할  수 있다

   <br />

#### 메소드

- 클래스나 구조체, 열거형과 같은 객체 내에서 함수가 선언될 경우 메소드라고 통칭

- 즉, 특정 타입의 객체 내부에서 사용하는 함수

- 인스턴스 메소드 : 인스터스를 생성한 후에 호출할 수 있는 메소드

   - 인스턴스 프로퍼티에 접근하거나 수정하는 방법을 제공하거나 인스턴스의 생성 목적에 따른 함수적 관계성을 제공하는 등 객체의 인스턴스에 대한 기능적 측면 제공

   - 구조체와 클래스의 인스턴스에 소속

   - 메소드 내에서 정의된 변수와 상수 뿐만 아니라 클래스 범위에서 정의된 프로퍼티도 모두 참조 가능

   - self 키워드 사용 가능

   - 구조체나 열거형의 인스턴스 메소드 내부에서 프로퍼티 값을 수정할 때는  메소드 앞에 __mutating__ 키워드를 명시해야 함

- 타입 메소드 : 객체 타입에서 호출할 수 있는 메소드

#### 상속

- 한 클래스가 다른 클래스에서 정의된 프로퍼티나 메소드를 물려받아 사용하는 것

- 서브 클래싱 : 기존 클래스를 기반으로 하여 새로운 클래스를 작성하는 과정

- 오버라이딩 : 자식 클래스에서 상속받은 메소드나 프로퍼티를 재정의하는 것

   - 프로퍼티 오버라이딩 시 허용되는 것

      - 저장 프로퍼티를 get, set 구문이 모두 있는 연산 프로퍼티로 오버라이딩하는 것

      - get, set 구문이 모두 제공되는 연산 프로퍼티를 get, set 구문이 모두 제공되는 연산 프로퍼티로 오버라이딩하는 것

      - get 구문만 제공되는 연산 프로퍼티를 get, set 구문이 모두 제공되는 연산 프로퍼티로 오버라이딩하는 것

      - get 구문만 제공되는 연산 프로퍼티를 get 구문만 제공되는 연산 프로퍼티로 오버라이딩하는 것

   - 프로퍼티 오버라이딩 시 허용되지 않는 것

      - 저장 프로퍼티를 저장 프로퍼티로 오버라이딩하는 것

      - get, set 구문과 관계 없이 연산 프로퍼티를 저장 프로퍼티로 오버라이딩하는 것

      - 저장 프로퍼티를 get 구문만 제공되는 연산 프로퍼티(읽기 전용)로 오버라이딩하는 것

      - get, set 구문을 모두 제공하는 연산 프로퍼티를 get 구문만 제공되는 연산 프로퍼티로 오버라이딩하는 것

   - 즉, 프로퍼티 오버라이딩은 상위 클래스의 기능을 제한하는 것이 아닌 확장, 변경하는 방식으로 진행되어야한다는 것

- 오버로딩 : 매개변수의 개수나, 타입, 이름 및 반환타입을 다르게 함으로써 같은 이름을 가진 메소드를 여러 개 만드는 것

- final 키워드 : 상위 클래스에서 정의한 메소드나 프로퍼티가 하위 클래스에서 오버라이딩되는 것을 차단하는 키워드, 클래스 자체에 붙이면 상속이 불가능한 클래스로 생성

- 타입 캐스팅 : 자식 클래스를 본래의 타입 대신 부모 클래스 타입으로 선언하여 사용하는 것

- 타입 비교 연산 : is 

   - 연산자 왼쪽 인스턴스의 타입이 비교대상 타입과 일치할 경우 - true

   - 연산자 왼쪽 인스턴스의 타입이 비교대상 타입의 하이 클래스일 경우 - true

   - 그 외 - false

- 타입 캐스팅 연산

   - 업 캐스팅

      - 하위 클래스 타입을 상위 클래스 타입으로 변환

      - 캐스팅한 결과, 캐스팅하기 전 타입보다 추상화될 때

      - 일반적으로 캐스팅 과정에서 오류 발생 X

      ```swift
      객체 as 변환할 타입
      ```

   - 다운 캐스팅

      - 상위 클래스 타입을 하위 클래스 타입으로 변환

      - 캐스팅한 결과, 캐스팅하기 전 타입보다 구체화될 때

      - 캐스팅 과정에서 오류 발생 가능성 있음

      - 오류에 대한 처리 방식에 따라 옵셔널 캐스팅과 강제 캐스팅으로 나뉘어짐

      ```swift
      객체 as? 변환할 타입(결과는 옵셔널 타입, 타입 캐스팅 실패시 nil 반환)
      객체 as! 변환할 타입(결과는 일반 타입, 타입 캐스팅 실패시 런타임 에러)
      ```

      <br />

#### Any, AnyObject

- AnyObject : 클래스의 일종으로, 모든 종류의 클래스 타입을 저장할 수 있는 범용 타입 클래스, 모든 클래스의 인스턴스는 AnyObject 클래스 타입으로 선언된 변수나 상수에 할당 가능

- Any : AnyObject와 비슷한 범용 객체이지만, 클래스에 국한되지 않고 스위프트에서 제공하는 모든 타입 허용

   - Any 타입의 남용은 스위프트에서 사용되는 정적인 타입들을 모두 동적인 타입으로 바꾸는 결과를 낳는다

   - 실행되기 전 값의 타입을 알기 어렵기 때문에 컴파일러가 오류를 잡아내지 못해 런타임 오류 발생 여지 다분

   <br />

#### 초기화 구문

- 인스턴스를 생성해 메모리 공간을 할당 받는 과정

- 멤버와이즈 초기화 구문 : 구조체 내부에 선언된 모든 저장 프로퍼티를 일괄로 외부의 값으로 초기화할 수 있는 구문

- 클래스의 경우에는 멤버와이즈 초기화 구문을 제공하지 않는다.

- init 초기화 메소드

   ```swift
   init(<매개변수>: <타입>, ...) {
   	1. 매개변수 초기화
   	2. 인스턴스 생성 시 기타 처리할 내용
   }
   ```

   1. 초기화 메소드의 이름은 init으로 통일

   1. 매개변수의 개수, 이름, 타입은 임의로 정의 가능

   1. 오버로딩 가능

   1. 정의된 초기화 메소드는 직접 호출되기도 하지만, 대부분 인스턴스 생성 시 간접적으로 호출

   - init 메소드를 정의하면 기본 초기화 구문은 제공되지 않는다.

   - init 메소드를 정의한 후 기본 초기화 구문을 사용하려면 직접 init() 메소드를 정의해야 함

   - 초기화 구문 델리게이션(Initializer Delegation) : 연쇄적으로 오버라이딩된 자식 클래스의 초기화 구문에서 부모 클래스의 초기화 구문에 대한 호출이 발생하는 것

   - 부모 클래스에서 기본 초기화 구문 외에 다른 형식의 초기화 구문이 추가되어 있다면, 자식 클래스에서 기본 초기화 구문을 오버라이딩할 때 명시적으로 부모 클래스의 기본 초기화 구문을 호출해야 한다

   - Convenience init

      - 보조 이니셜라이저

      - 동일 클래스에 구현되어있는 다른 지정 생성자를 호출해야 함

   <br />

#### 옵셔널 체인

- 옵셔널 연산자를 이용하여 옵셔널 속성을 연결해서 처리하는 것

- 객체가 nil인 상황에서 안정성 검사를 하지 않고 메소드나 프로퍼티를 호출하더라도 오류를 발생하지 않음

- 옵셔널 체인으로 참조된 값은 무조건 옵셔널 타입으로 반환

   - 옵셔널 체인이라는 구문 자체가 nil을 반환할 가능성을 내포하고 있기 때문

- 옵셔널 체인 과정에서 옵셔널 타입들이 여러 번 겹쳐 있더라도 중첩되지 않고 한 번만 처리

   - startup?.ceo?.name ≠ Optional(Optional("대표")) 

   - startup?.ceo?.name == Optional("대표")

   <br />

### 열거형과 익스텐션

<br />

#### 열거형

- 하나의 주제로 연관된 데이터들이 멤버로 구성되어 있는 자료형 객체

- 입력받아야 할 정보들을 입력 대신 '선택'할 수 있도록 함으로써 값의 범위를 제한

- 무작위로 값이 입력되는 것을 방지하여 코드의 안정성을 높여줌

   ```swift
   enum 열거형이름 {
   	case 멤버값1
   	case 멤버값2
   	case ...
   }
   ```

- 열거형 타입으로 정의된 변수에는 열거형 타입명을 생략하고 멤버값만 대입 가능

- 변수나 상수의 타입 어노테이션을 명시한 경우, 처음부터 타입명 생략 가능

- 타입 어노테이션 없이 변수나 상수를 초기화할 때 타입명 생략 불가능

- __연관 값(Associated Values)__ : 사용하는 시점에서 멤버에 보조 값을 설정되어지는 값

   ```swift
   enum ImageFormat {
   	case JPEG
   	case PNG(Bool)
   	case GIF(Int, Bool)
   }
   
   var newImage = ImageFormat.PNG(true)
   newImage = .GIF(256, false)
   ```

- PNG는 배경값이 투명한 PNG와 그렇지 않은 PNG 포맷으로 나뉠 수 있고 GIF는 사용된 컬러 수와 애니메이션 여부에 따라 나눌 수 있다. 이러한 특성을 모두 반영하여 이미지 포맷의 멤버를 정의하면 필요한 멤버 수가 기하급수적으로 늘어난다. 따라서 모두 정의하지 않고 연관 값으로 처리하면 멤버 수를 줄일 수 있다.

- 연산 프로퍼티와 메소드를 정의할 수 있음

#### 익스텐션

- 이미 존재하는 클래스나 구조체, 열거형 등의 객체에 새로운 기능을 추가해 확장해주는 구문

- 기존에 작성된 객체를 직접 수정하지 않고도 기능을 추가하는 방법을 제공

- 익스텐션을 통해 구현할 수 있는 것

   - 새로운 연산 프로퍼티 추가

   - 새로운 메소드 정의

   - 새로운 초기화 구문 추가

   - 기존 객체를 수정하지 않고 프로토콜 구현

- 하지만 기존 객체에서 사용된 같은 메소드를 재정의하는 것은 불가능

- 하지만 익스텐션을 남용하면 객체의 정의를 모호하게 만들거나 각 실행 위치에 따라 서로 다른 정의로 구성된 객체를 사용하게 만드는 결과를 낳을 수 있음

- 객체의 정의가 파편화되기 쉬운 까닭에 객체의 정확한 구성을 파악하기 어렵다는 단점도 존재

<br />

### 프로토콜

- 클래스나 구조체가 어떤 기준을 만족하거나 또는 특수한 목적을 달성하기 위해 구현해야 하는 메소드와 프로퍼티의 목록

- 객체지향 언어의 인터페이스와 거의 비슷한 개념

- 기능이나 속성에 대한 설계도

   ```swift
   protocol 프로토콜명 {
   	구현해야 할 프로퍼티 명세1
   	구현해야 할 프로퍼티 명세2
   	...
   
   	구현해야 할 메소드 명세1
   	구현해야 할 메소드 명세2
   	...
   }
   ```

#### 프로토콜 프로퍼티

- 프로토콜에 선언되는 프로퍼티에는 초기값을 할당할 수 없다

- 연산 프로퍼티인지 저장 프로퍼티인지도 구분하지 않는다

- 프로퍼티의 종류, 이름, 변수/상수 구분, 타입, 읽기 전용인지 읽고 쓰기가 가능한지에 대해서만 정의

   ```swift
   // example
   protocol SomePropertyProtocol {
   	var name: String { get set }
   	var description: String { get }
   }
   ```

   <br />

#### 프로토콜 메소드

- 프로토콜에서 정의된 메소드는 구현체에서도 매개변수명까지 일치해야 한다

- 단, 일치시켜야 하는 매개변수명은 외부로 드러나는 매개변수명에 국한된다

- 프로토콜에서 메소드가 mutating으로 선언되어 있지 않다면 구현체에서 mutating으로 구현할 수 없다

- 다만 프로토콜에선 mutating으로 선언되어 있지만 구현체에서 내부 프로퍼티를 변경하지 않는다면 mutating 키워드를 붙일 필요 없다

- 클래스의 경우에는 mutating 키워드가 붙어있는 프로토콜 메소드를 구현할 때에도 mutating 키워드를 붙이지 않는다

- 프로토콜에서도 타입 메소드나 타입 프로퍼티를 정의할 수 있다 (static 키워드)

- 단, 프로토콜에서 class 키워드로 정의할 수 없다(구조체, 열거형, 클래스 모두 사용할 수 있는 형식으로 정의되어야 하므로)

- 하지만 프로토콜에선 static으로 선언되어 있어도 클래스 구조체에서 class 키워드를 붙일 수 있다

- 초기화 메소드도 프로토콜에서 정의 가능하다

- 구현되는 초기화 메소드의 이름과 매개변수명은 프로토콜의 명세와 동일해야 한다

- 프로토콜 명세에 선언된 초기화 메소드는 그것이 기본 제공되는 초기화 메소드라도 직접 구현해야 한다

- 클래스에서 초기화 메소드를 구현할 때는 required 키워드를 붙여야 한다

- 클래스가 상속해야 할 클래스와 프로토콜이 있다면 상속에 대한 선언부터 해야 한다

<br />

#### 타입으로서의 프로토콜

- 상수나 변수, 그리고 프로퍼티의 타입으로 사용할 수 있음

- 함수, 메소드 또는 초기화 구문에서 매개변수 타입이나 반환 타입으로 사용할 수 있음

- 배열이나 딕셔너리, 혹은 다른 컨테이너의 타입으로 사용할 수 있음

- 필요에 따라 두 개 이상의 특정 프로토콜들을 타입으로 사용할 수 있다 (& 연산자를 통해)               ex)let protocol: ProtocolA & ProtocolB = ...

- 프로콜을 타입으로 정의하 경우 대입된 실제 타입과 상관없이 프로토콜 타입에 정의된 메소드나 프로퍼티만 사용할 수 있다

<br />

#### 익스텐션과 프로토콜

- 특정 객체에서 프로토콜을 구현해야 할 경우, 객체 자체의 코드를 수정하여 직접 구현할 수도 있지만 이를 대신해 익스텐션에서 프로토콜을 구현할 수도 있다

- 단, 익스텐션에서 저장 프로퍼티를 정의할 수는 없다. 따라서 프로토콜에서 정의된 프로퍼티를 익스텐션에서 구현해야 한다면, 연산 프로퍼티로 구현해 주어야 한다

<br />

#### 프로토콜의 상속

- 프로토콜은 클래스와 다르게 다중 상속 가능

- 프로토콜을 상속할 때 부모 프로토콜에서의 선언과 자식 프로토콜에서의 선언이 겹치더라도 클래스처럼 override 키워드를 붙여야 하는 제약이 없다

<br />

#### 클래스 전용 프로토콜

- 프로토콜을 클래스만 구현할 수 있도록 제한된 프로토콜을 정의할 수 있다. 이를 클래스 전용 프로토콜이라 한다.

- 과거에는 프로토콜 이름 뒤에 콜론으로 구분하여 class 키워드를 사용하면 됐지만 현재는 deprecated 됐다

- 현재는 AnyObject 키워드를 붙여서 클래스 전용 프로토콜 선언

   ```swift
   protocol SomeClassOnlyProtocol: AnyObject {
   	// 구현 내용
   }
   ```

- 만약 프로토콜이 다른 프로토콜을 상속받는다면 상속된 프로토콜을 나열하기 전 맨 먼저 클래스 전용임을 표시해야 한다. 

   ```swift
   protocol SomeClassOnlyProtocol: AnyObject, ParentA, ParentB {
   	// 구현 내용
   }
   ```

   <br />

#### Optional in 프로토콜

- 프로토콜을 구현할 때에는 기본적으로 프로토콜의 명세에 포함된 모든 프로퍼티나 메소드, 초기화 구문을 구현해야 한다

- 하지만 선택적 요청(Optional Requirement)을 통해 구현해야 할 때 작성해야 하는 요소들을 선택 사항으로 바꿀 수 있다

- optional 키워드를 사용하여 프로퍼티나 메소드, 초기화 구문 앞에 표시한다

- 프로토콜에서 optional 키워드를 사용하기 위해서는 프로토콜 앞에 @objc를 표시해야 한다

   - @objc : 파운데이션 프레임워크에 정의된 어노테이션의 일종, 이 어노테이션이 붙은 객체나 코드를 Objc 코드에서 참조할 수 있도록 노출됨을 의미

- @objc 어노테이션이 붙은 프로토콜은 클래스에서만 구현할 수 있다

<br />

### 오류 처리

- 스위프트에서 오류를 처리하는 방법은 크게 두 가지이다

   - 옵셔널

   - 오류 처리 구문

   <br />

#### 오류 처리 구문

- 초기에 발표된 스위프트는 옵셔널을 통해 오류를 충분히 처리할 수 있다고 강조했지만 이 부분에는 오류가 발생했을 때 오류에 대한 정보를 외부로 전달할 방법이 없다는 단점이 존재했다

- 따라서 스위프트2부터 오류 처리 구문을 도입하여 오류를 반환하는 것 뿐만 아니라 오류를 '던지는(throw)' 처리를 할 수 있게 되었다

- 오류 타입으로 사용되는 열거형은 반드시 Error 프로토콜을 구현해야 한다

- Error는 아무 기능도 정의되지 않은 빈 프로토콜

   - 간혹 빈 프로토콜을 볼 수 있는데 이들은 프로토콜의 기능 구현보다는 프로토콜을 구현했다는 사실 자체가 중요한 경우가 많다

   - 이 프로토콜을 구현한 열거형은 오류 타입으로 사용해도 된다는 보증서 같은 개념

   <br />

#### 오류 던지기

- 함수나 메소드는 오류 객체를 외부로 던질 수 있다는 것을 컴파일러에 알려주기 위해 정의 구문에 throws 키워드를 추가해야 한다

- throws 키워드는 반환 타입을 표시하는 화살표 (->)보다 앞에 작성해야 한다

- 함수나 메소드, 또는 익명 함수인 클로저도 throws 키워드 사용 가능

   ```swift
   func canThrowErrors() throws -> String
   
   {() throws -> String in 
   }
   ```

   <br />

#### 오류 객체 잡아내기


```swift
do {
	try <오류를 던질 수 있는 함수>
} catch <오류 타입1> {
	// 오류 타입1에 대한 대응
} catch <오류 타입2> {
	// 오류 타입2에 대한 대응
} catch ...
```

- 오류를 던지도록 설계된 함수나 메소드지만, 필요에 의해 오류를 던지지 않게 하고 싶을 때에는 try 대신 try! 키워드를 사용한다.

   ```swift
   let date = try! parseDate(param: "2015-09-31")
   ```

- try! 키워드를 사용해 오류가 발생하면 런타임 오류로 이어진다

<br />

### 값 타입과 참조 타입

#### 값 타입

- 값 타입으로 선언된 값은 메모리의 스택 영역에 저장

- 파라미터로 전달되거나 리턴 값으로 사용될 때 같은 값을 가진 복사본이 생성

- 스택 공간에 생성된 값 타입의 메모리는 자신이 속한 범위(Scope)의 코드 실행이 종료되면 자동으로 제거

- 구조체, 열거형, 기본 자료형

#### 참조 타입

- 참조 타입으로 선언된 값은 스택과 힙 영역에 저장, 값은 힙 영역에 저장되고 스택 영역에는 힙 영역에 저장된 값의 주소를 저장

- 참조 형식은 선언 후 값을 초기화하지 않으면 기본적으로 nil이 저장

- 즉, 스택 공간에 생성된 변수의 메모리에는 0x0 주소가 저장, 그리고 초기값을 지정하지 않았으므로 힙 영역에는 메모리 공간이 생성되지 않는다

- 클래스, 클로저

<br />

#### 박싱과 언박싱

- 박싱 : 값 타입을 참조 타입으로 바꾸는 것

- 언박싱 : 참조 타입을 값 타입으로 바꾸는 것

<br />

#### Exponential growth 전략

- 스위프트는 위 전략을 통해 새로운 메모리 공간을 할당할 때마다 이전보다 두 배 이상 큰 공간을 할당

#### Copy On Write(COW) 전략

- 데이터를 수정하려고 할 때까지 컴파일러는 값 타입의 복사본을 생성하지 않고 참조를 전달한다

<br />

<br />

### 서브스크립트

- [ ]와 첨자를 사용해서 인스턴스 속성에 접근할 수 있는 문법

- 클래스, 구조체, 열거형에서 구현 가능

- 이름이 없는 메소드로 볼 수 있고 파라미터 목록과 리턴형을 선언하는 문법은 메소드와 동일

- 서브스크립트는 파라미터와 리턴형 생략 불가능

```swift
subscript(파라미터 목록) -> 리턴형 {
	get {
		값을 리턴하는 코드
	}
	set {
		값을 설정하는 코드
	}
}
```

<br />

### 제네릭

- 일반화 프로그래밍이라고도 함

- 자료형에 의존하지 않고 범용 코드를 작성해 재사용성과 편의성을 높이는 프로그래밍 방법

- 형식 제약(Type Constraints)

   ```swift
   func compare<T: Equatable>(lhs: T, rhs: T) -> Bool {
   	return lhs == rhs
   }
   ```

   - 형식 제약으로 지정할 수 있는 형식은 클래스와 프로토콜로 한정

   <br />

#### 연산자 메소드

- 기본적으로 제공되는 연산자 구현에 새로운 구현을 추가할 때(오버로딩) 사용

```swift
static func 연산자(파라미터 목록) -> 리턴형 {
	// ...
}
```

<br />

- 단항 연산자 오버로딩

   - 단항 연산자 : -a와 같이 피연산자가 하나인 연산자

   - 전치 연산자(prefix operator) : 연산자가 피연산자의 앞에 위치하는 경우, 전치 연산자를 오버로딩하는 경우 prefix 키워드 사용

      ```swift
      struct KOffset {
      	var x = 0.0
      	var y = 0.0
      
      	prefix static func -(offset: KOffset) -> KOffset {
      			return KOffset(x: -offset.x, y: -offset.y)
      	}
      }
      
      let offset = KOffset(x: -100, y: 200)
      let newOffset = -offset
      print(newOffset)   // {100, -200}
      ```

   - 후치 연산자(postfix operator) : 연산자가 피연산자 뒤에 위치하는 경우, postfix 키워드 사용

      ```swift
      struct KSize {
          var width = 0.0
          var height = 0.0
          
          postfix static func ++(size: inout KSize) -> KSize {
              let current = size
              size = KSize(width: size.width + 1, height: size.height + 1)
              return current
          }
      }
      
      var size = KSize(width: 5, height: 5)
      print(size++) // KSize(width: 5.0, height: 5.0)
      print(size)   // KSize(width: 6.0, height: 6.0)
      ```

- 이항 연산자 오버로딩

   - 이항 연산자 : a + b와 같이 피연산자가 두 개인 연산자

      ```swift
      struct KSize {
          var width = 0.0
          var height = 0.0
          
          static func +(lhs: KSize, rhs: KSize) -> KSize {
              return KSize(width: lhs.width + rhs.width, height: lhs.height + rhs.height)
          }
          
          static func *(lhs: KSize, rhs: Double) -> KSize {
              return KSize(width: lhs.width * rhs, height: lhs.height * rhs)
          }
          
          static func *(lhs: Double, rhs: KSize) -> KSize {
              return KSize(width: lhs * rhs.width, height: lhs * rhs.height)
          }
      }
      
      let size1 = KSize(width: 5, height: 5)
      let size2 = KSize(width: 3, height: 3)
      print(size1 + size2) // KSize(width: 8.0, height: 8.0)
      print(size1 * 3.0)   // KSize(width: 15.0, height: 15.0)
      print(3.0 * size1)   // KSize(width: 15.0, height: 15.0)
      ```

- 복합 할당 연산자 오버로딩

   - 연산의 결과가 왼쪽 피연산자에 할당되기 때문에 왼쪽 피연산자를 반드시 입출력 파라미터(inout)으로 전달해야 한다

      ```swift
      struct KSize {
          var width = 0.0
          var height = 0.0
          
          static func +=(lhs: inout KSize, rhs: KSize) {
              lhs = KSize(width: lhs.width + rhs.width, height: lhs.height + rhs.height)
          }
      }
      
      var size = KSize(width: 5, height: 5)
      size += KSize(width: 3, height: 3)
      print(size)   // KSize(width: 8.0, height: 8.0)
      ```

- 비교 연산자 오버로딩

   - 이항 연산자와 동일한 방식으로 오버로딩, 리턴형에 제약이 있는 것은 아니지만 일반적으로 Bool 리턴

      ```swift
      struct KSize {
          var width = 0.0
          var height = 0.0
          
          static func ==(lhs: KSize, rhs: KSize) -> Bool {
              return lhs.width == rhs.width && lhs.height == rhs.height
          }
          
          static func !=(lhs: KSize, rhs:KSize) -> Bool {
              return lhs.width != rhs.width || lhs.height != rhs.height
          }
      }
      
      let size1 = KSize(width: 5.0, height: 5.0)
      let size2 = KSize(width: 5.0, height: 5.0)
      
      print(size1 == size2)  // true
      print(size1 != size2)  // false
      ```

      <br />

      <br />

      <br />

### 메모리 관리

#### 소유 정책

- 참조 카운트를 관리하는 규칙

- 모든 객체는 생성될 때 참조 카운트가 1이 된다.

- 객체에 retain 메시지를 보내면 참조 카운트가 1 증가한다. 이 메시지를 보낸 호출자는 객체를 소유한다.

- 객체에 release 메시지를 보내면 참조 카운트가 1 감소한다. 이 메시지를 보낸 호출자는 객체의 소유권을 포기한다.

- autorelease 메시지를 보내면 현재 사용 중인 오토릴리즈 풀 블록(autorelease pool block)의 실행이 종료되는 시점에 참조 카운트가 1 감소한다. 이 메시지를 보낸 호출자는 객체의 소유권을 포기한다.

- 참조 카운트가 0이 되면 객체의 메모리가 해제된다.

<br />

#### Autorelease Pool

- autorelease 메시지를 받은 객체가 해제되기 전까지 저장되는 공간

- 이 공간에 저장된 객체들은 오토릴리즈 풀이 해제될 때 release 메시지를 받는다.

- 하나의 객체가 여러 번 추가되었다면 추가된 횟수만큼 release 메시지를 받는다.

- Xcode로 생성하는 모든 프로젝트는 메인 스레드에서 동작하는 기본 오토릴리즈 풀을 제공한다.

- 모든 스레드는 오토릴리즈 풀 스택을 갖고 있고, 새롭게 생성된 오토릴리즈 풀은 스택 최상위에 추가된다.

- autorelease 메시지를 받은 객체는 자신의 스레드에 존재하는 오토릴리즈 풀 중 스택 최상위에 있는 풀에 추가도니다.

- 오토릴리즈 풀이 해제되는 경우 스택에서 제거되고 여기에 포함된 모든 객체들은 release 메시지를 받는다.

- 스레드 자체가 종료되는 경우에도 스택에 있는 모든 풀이 자동으로 해제된다.

```swift
autoreleasepool {
	// ...
}
```

<br />

#### Automatic Reference Counting(ARC)

- 스위프트에서 사용하는 메모리 관리 모델

- 컴파일러가 코드를 분석한 후 객체의 생명주기에 적합한 메모리 관리 코드를 추가하는 방식

- 프로그래머가 직접 메모리를 관리하지 않는다는 측면에서 자바의 가비지 컬렉션과 유사하지만 차이점이 있다.

   - 런타임에 주기적으로 메모리를 정리하는 GC와 달리 컴파일 시점에 코드가 자동으로 추가되는 방식이므로 런타임에 메모리 관리를 위한 오버헤드가 발생하지 않는다

- ARC는 객체를 생성할 때마다 객체에 대한 정보를 저장하는 별도의 메모리 공간을 생성한다.

- 이 공간에 객체에 대한 형식 정보와 속성 값이 저장되고 이를 바탕으로 메모리를 관리한다.

1. Strong Reference(강한 참조)

   - 인스턴스를 다른 속성, 변수, 상수에 할당할 때 참조 횟수가 1이 증가하고 nil을 할당하면 참조 횟수 1 감소한다.

   - 별도의 식별자가 없다면 강한 참조로 인식

   - 강한 참조의 경우 인스턴스끼리 서로 강한 참조를 소유하고 있을 때 강한 참조 사이클 문제(strong retain cycle)문제가 발생할 수 있다. ARC는 이러한 참조 사이클 문제를 스스로 해결할 수 없다.

1. Weak Reference(약한 참조)

   - 자신이 참조하는 객체에 대해 강한 참조를 유지하지 않는다. 즉, 인스턴스를 할당할 때 참조 횟수를 증가시키지 않는다.

   - 약한 참조로 선언하기 위해서는 반드시 옵셔널로 선언해야 한다.

   - 약한 참조로 참조 사이클 문제를 해결할 수 있다.

1. Unowned Reference(미소유 참조)

   - 참조 대상에 대한 강한 참조를 소유하지 않지만 항상 유효한 대상을 참조한다.

   - 즉, 약한 참조와 달리 옵셔널로 선언되지 않고 nil 값을 가질 수 없다

   - 참조 대상이 해제되는 경우 자동으로 nil로 변경되지 않기 때문에 런타임 오류 발생 가능성이 크다.

#### 클로저의 강한 참조 사이클 문제

- 클로저는 클래스와 마찬가지로 참조 형식이기 때문에 참조 사이클 문제로부터 자유로울 수 없다

- 클로저 캡처 목록(Closure Capture List)를 통해 해결할 수 있다.

   ```swift
   {
       [weak 캡처 대상] (파라미터 목록) -> 리턴형 in
       // ...
   }
   ```

   <br />

