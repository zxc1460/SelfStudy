# Swift

### 스위프트 언어의 특징

- 빠름(Fast)

   - 복합정렬 벤치마크를 보면 파이썬보다 대략 3.9배 빠름, Objc보다 약 2.8배 빠름

   - LLVM 컴파일러에서 제공하는 코드 최적화기를 사용해 소스 컴파일과 최적화를 수행

- 설계에 의한 안정성(Safety by Design)

   - 변수나 상수는 반드시 선언한 후에 사용하도록 강제

   - 타입 추론 기능에 의해 변수의 초기값을 기준으로 타입 정의

   - 배열과 정수는 오버플로우에 대비하여 확인

   - 개발자가 정의하지 않은 배열 값에 승인하지 않은 값들이 주입될 수 없도록 Array bounds check

   - 포인터에 직접 접근하는 시도 차단, 클래스를 통해 간접적으로만 레퍼런스 참조하도록 제한

   - ARC를 이용해 자동으로 메모리 관리

- 현대적(Modern)

   - 파이썬 언어에 기반을 둔 읽고 쓰기 쉬운 문법

   - 헤더 파일 사용 대신 메인 파일에 통합하여 코드 작성

- 상호반응(Interactive)

- 완전한 플랫폼(Complete Platform)

   - Objc 코드에 의존하지 않고도 프로그램 작성 가능

- 통합(Unified)

<br />

### 스위프트의 기초 문법 특징

- 헤더 파일을 작성할 필요가 없다.

   - 기존의 Objc는 헤더 파일과 메인 파일로 분리되어 있었지만, 스위프트는 헤더와 소스 파일이 통합된 하나의 *.swift 파일에 필요한 내용을 자유롭게 정의하고 사용

- 대소문자 구분

- 구문 끝의 세미콜론은 생략 가능

   - 한 줄에 두 개 이상의 구문을 작성할 때는 세미콜론을 붙여야 함

- 엔트리 포인트(시작점)으로 사용되는 main() 함수가 없음

   - 다만, @UIApplication 어노테이션을 사용해 앱을 시작하는 객체 지정

- String 뿐만 아니라 Character도 큰 따옴표 사용

- import 키워드를 사용하지만, 라이브러리와 프레임워크의 참조 용도

- C나 자바처럼 한 줄 주석, 여러 줄 주석 처리 방식을 모두 지원

   - // : 한 줄 주석

   - /* ~ */ : 여러 줄 주석

- try ~ catch 방식의 오류 처리 지원

<br />

### 변수와 상수

- 저장한, 혹은 저장할 메모리 주소값을 이름으로 연결해 놓은 것

- 둘 다 값을 저장할 수 있지만 상수는 한 번 저장된 값을 다른 값으로 변경할 수 없음

- 변수의 값을 변경할 수 있다고 하더라도 처음 저장했던 값과 일치하는 타입으로만 변경 가능

- 스위프트는 '타입 추론기'라는 기능 모듈을 컴파일러에 별도로 내장하여, 항상 최적의 타입을 결정

- 변수명, 상수명 정의

   - 알파벳과 한글 자음 및 모음, 아라비아 숫자, 특수 기호, 한자, 이미지용 바이너리 코드 모두 사용 가능 → 사용할 수 있다의 정도지 영어, 숫자, 밑줄 이외의 다른 문자나 기호 절대 쓰지 말것

   - 연산자와 혼동할 수 있는 +, -, *, / 및 공백은 사용할 수 없음(언더바는 가능)

   - 예약어나 키워드로 등록되어 있는 단어 사용 불가능. 단, 대소문자 변경 시 사용 가능

   - 첫 번째 자리에 숫자는 올 수 없음

### 기본 자료형(Data Types)

- Int

   - Int8, Int16, Int32, Int64 등으로 이어지는 int 계열 서브 자료형의 대표 자료형

   - 부호 있느 정수 자료형

   - 해당 컴퓨터의 CPU 비트 크기에 맞춰 자동으로 그 크기 변화

- UInt

   - 부호 없는 정수, 양수만 저장 가능

- Double & Float

   - 실수 값을 저장할 수 있는 자료형

   - Double : 64비트 부동 소수점 자료형 (소수점 아래 15~16자리)

   - Float : 32비트 부동 소수점 자료형 (소수점 아래 7~8자리)

- Bool

   - true / false 두 값만 가질 수 있는 논리값을 저장하는 자료형

- String

   - 문자열을 저장할 수 있는 집단 자료형

   - NSString과 String 사이의 타입 변환은 오류 발생 여지가 없는 완전 변환

- Character

   - 한 개의 문자를 저장할 수 있는 단일 자료형

   - Character 타입의 데이터 값을 표현할 때도 큰 따옴표 사용

   <br />

### 타입 어노테이션(Type Annotation)

- 변수나 상수를 선언할 때 타입을 명시적으로 선언해주는 것

- 변수나 상수명 뒤에 콜론(:)을 붙여서 타입 지정

- ex) var year: Int?

### 타입 추론(Type inference)

- 변수나 상수를 초기화할 때 입력된 값을 분석하여 변수에 적절한 타입을 컴파일러가 스스로 추론하는 기능

- 주어진 값이 타입 A와 타입 B에 동시에 속하는 경우, 더 넓은 범위의 타입으로 결정

- 더 작은 범위의 타입으로 정의하려면 반드시 타입 어노테이션을 통해 명시적으로 선언해야 함

### 문자열 템플릿

- 문자열에 변수를 포함시킬 때 좀 더 직관적이고편하게 사용하기 위한 기능

- "문자열 \(변수)"처럼 \() 안에 변수명을 넣어서 사용

### 쿼우팅(Quoting)

- 문자열을 따옴표로 묶어서 표시하는 방법

- 스위프트에서는 문자열, 문자 모두 "(큰따옴표)로 표시

- 멀티 라인 스트링

   - 스위프트 4.0부터 도입된 문법

   - 큰따옴표 세 개를 연속으로 붙여(""" ~ """) 그 내부에서 자유롭게 작성된 문자열을 실제 내용으로 처리하는 방식

   - 트리플 쿼우팅(Triple-Quoting)이라고 불리기도 함

   - 트리플 쿼우팅이 시작된 후에는 줄바꿈 후 입력을 시작해야 하고, 종료할 때에도 줄바꿈하여 쿼우팅을 닫아야 함

   <br />

### 연산자

<br />

| 구분 | 연산자 | 사용 예 | 의미 |
 | --- | --- | --- | --- |
| 단항 연산자 | - | -a | 값의 부호 변경 |
| 이항 연산자 | + | a + b | 두 개의 값을 더함 |
|     | - | a - b | 앞의 값에서 뒤의 값을 뺌 |
|     | * | a * b | 두 개의 값을 곱함 |
|     | / | a / b | 앞의 값을 뒤의 값으로 나눔 |
|     | % | a % b | 앞의 값을 뒤의 값으로 나눈 나머지 |

<br />

| 연산자 | 사용 예 | 의미 |
 | --- | --- | --- |
| < | a < b | a가 b보다 작으면 true |
| > | a > b | a가 b보다 크면 true |
| <= | a <= b | a가 b보다 작거나 같으면 true |
| >= | a >= b | a가 b보다 크거나 같으면 true |
| == | a == b | a가 b와 같으면 true |
| != | a != b | a와 b가 다르면 true |

<br />

| 연산자 | 사용 예 | 의미 |
 | --- | --- | --- |
| ! | !a | a가 true면 false 반환, false면 true 반환 |
| && | a && b | a와 b 모두 true면 true 반환 하나라도 false면 false 반환 |
| || | a || b | a와 b 둘 중 하나라도 true면 true 반환 둘 다 false면 false 반환 |

#### 범위 연산자

- 닫힌 범위 연산자(Closed range operator)

   - 주어진 피연산자 a, b를 포함하는 범위를 나타내는 연산자

   - ex) 1...5 : 1부터 5까지의 범위

- 반 닫힌 범위 연산자(Half-closed range operator)

   - 연산자 양쪽 경계 중 왼쪽 경계는 포함하되 오른쪽 경계는 포함하지 않는 연산자

   - ex) 1..<5 : 1부터 4까지의 범위

- 범위 연산자의 왼쪽에는 작은 숫자, 오른쪽에는 그보다 큰 숫자를 배치해야 한다 그렇지 않다면 런타임 오류가 뜨기 때문에 주의해야 함

<br />

| 연산자 | 사용 예 | 의미 |
 | --- | --- | --- |
| = | a = 1 | 변수 a에 1을 대입 |
| += | a += 1 | a = a + 1 |
| -=  | a -= 1 | a = a - 1 |
| *= | a *= 2 | a = a * 2 |
| /= | a /= 3 | a = a / 3 |
| %= | a %= 3 | a = a % 3 |
| <<= | a <<= 3 | a = a << 3 |
| >>= | a >>= 3 | a = a >> 3 |
| &= | a &= b | a = a & b |
| ^= | a ^= b | a = a ^ b |
| |= | a |= b | a = a | b |

<br />

### 흐름 제어 구문

- 프로그램 실행 과정에서 실행 흐름을 능동적으로 제어하기 위한 목적으로 사용되는 구문

- 반복문 : 주어진 조건에 따라 특정 코드 블록을 반복적으로 실행

- 조건문 : 특정 조건이 성립할 경우 지정된 코드 블록이 실행되도록 제어

- 특정 지점의 코드로 실행 제어를 옮겨줌으로써 코드가 실행되는 순서를 제어

<br />

#### 반복문

- For 반복문

   - for <루프 상수> in <순회 대상> { <실행 구문> }

   - 순회 대상 데이터 타입

      - 배열

      - 딕셔너리

      - 집합

      - 범위 데이터

      - 문자열

   - 루프 상수 생략 가능 for _ in ~

- while 구문

   - while <조건식> { <실행 구문> }

   - 조건식을 만족하는 동안 계속 실행

- reepat ~ while 구문

   - repeat { 

         <실행 구문>

      }

      while <조건식>

   - 실행 구문의 수행을 최소 한 번 보장

   <br />

#### 조건문

- if 구문

   - if <조건식> { <실행 구문> }

   - 조건을 만족하면 코드 블록 실행

- guard 구문

   - guard <조건식 또는 표현식> else { <실행 구문> }

   - 결과가 false일 때 실행 구문 수행

   - 주로 후속 코드들이 실행되기 전 특정 조건을 만족하는지 확인하는 용도로 사용

   - 즉, 특정 조건을 만족하지 않은 채로 후속 코드를 실행하면 심각한 오류가 발생하는 경우, 전체 구문을 조기 종료하기 위한 목적으로 사용

- #available 구문

   - OS 버전과 기기를 체크하기 위한 구문

   - ex) if #available(iOS 9, OSX 10.10, watchOS 1, *) {}

- switch 구문

   - switch <비교 대상> {

         case <비교 패턴>:

         default:

      }

   - C나 자바와 문법이 유사하지만 C나 자바는 비교 패턴이 일치하는 경우 우선 실행 구문을 처리한 후 나머지 case에 대한 비교를 계속 진행하지만  스위프트는 일치하는 비교 패턴이 있을 경우 실행 코드 처리 후 전체 분기문 종료

   - 따라서 각 case 별로 break 구문 생략 가능

   - 암시적인 Fall Through 지원 X: 일치하는 case 블록을 실행하는 대신, 그 다음 case 블록으로 실행 흐름 전달

   - 대신 명시적으로 fallthrough 구문을 사용함으로써 Fall Through 지원

   - 스위프트에서는 case 키워드 다음에 하나 이상의 비교 패턴을 연이어 작성 가능

   - 튜플 내부의 아이템이 비교 대상과 부분적으로 일치하는 경우, 패턴 전체가 일치하는 것으로 간주

      ```swift
      var value = (2, 3)
      
      switch value {
      case let (x, 3):
      	print("튜플의 두 번째 값이 3일 때 첫 번째 값은 \(x)입니다")
      case let (3, y):
      	print("튜플의 첫 번째 값이 3일 때 두 번째 값은 \(y)입니다")
      case let (x, y):
      	print("튜플의 값은 각 \(x), \(y)입니다")
      }
      ```

   - 범위 연산자도 사용 가능

      ```swift
      var passtime = 1957
      
      switch passtime {
      case 0..<60:
      case 60..<3600:
      case 3600..<86400:
      default:
      }
      ```

   <br />

   #### 제어 전달문

   - break : switch 구문에서의 실행 흐름이나 반복 실행 중인 루프를 조건식의 결과와 상관 없이 즉각 종료

   - continue : 이 구문 아래에 있는 실행 구문들을 건너 뛰고 다음 반복을 시작

   <br />

   <br />

   ### 집단 자료형

   - 배열(Array) : 순서에 따라 데이터가 정렬된 목록 형태의 자료형

   - 집합(Set) : 중복되지 않은 유일 데이터들이 모인 집합 형태의 자료형

   - 튜플(Tuple) : 종류에 상관없이 데이터들을 모은 자료형, 수정 및 삭제 불가능

   - 딕셔너리(Dictionary) : 배열과 유사하나 인덱스 대신 키(Key)를 사용하여 Key-Value로 연관된 데이터들이 순서 없이 모인 자료형

   <br />

   #### 배열

   - 배열에 저장할 아이템의 타입에는 제약이 없지만, 하나의 배열에 저장하는 아이템의 타입은 모두 같아야 함

   - 선언 시 배열에 저장할 아이템 타입을 명확히 정의해야 함

   - 배열의 크기는 동적으로 확장할 수 있음

   #### 집합

   - 내부적으로 해시 연산의 결과값을 이용해 데이터를 저장하므로 데이터 타입은 해시 연산을 할 수 있는 타입이어야 함

   - 기본 타입이 아닌 임의로 만든 타입을 집합으로 사용하려면 Hashable 프로토콜을 구현해야 함

   - 기본 집합 연산

      - intersection(_:) : 양쪽 집합에서 공통되는 아이템을 선택해 새로운 집합을 만드는 메소드(교집합)

      - symmetricDifference(_:) : 양쪽 집합 중에서 한 쪽에만 있는 아이템을 선택하여 새로운 집합을 만드는 메소드, 양쪽 집합에 공통으로 있는 아이템은 제외

      - union(_:) : 양쪽 집합에 있는 모든 아이템을 선택하여 새로운 집합을 만드는 메소드(합집합)

      - subtract(_:) : 한쪽 집합에 있는 아이템에서 다른 쪽 집합에도 속하는 공통 아이템을 제외하고 새로운 집합을 만드는 메소드(차집합)

   - 부분집합과 포함관계 판단 연산

      - isSubset(of:) : 하나의 집합이 다른 집합의 부분집합인지 여부 판단

      - isSuperset(of:) : 하나의 집합이 다른 집합의 상위집합 역할을 하는지 판단

      - isDisjoint(with:) : 두 집합 사이의 공통 값이 없으면 true 하나라도 있으면 false

   #### 튜플

   - 여러 가지 타입의 아이템을 저장할 수 있지만, 선언되고 나면 상수적 성격을 띠므로 값을 추가하거나 삭제하는 등 변경 불가능

   - 하나의 아이템만 있는 튜플은 일반 자료형이 된다. ex) var tpl: (String) = ("tuple") == var tpl: String = "tuple"

   - 튜플의 아이템을 개별 변수나 상수로 각각 할당받는 바인딩 방식의 구문도 제공

   #### 딕셔너리

   - 고유 키(Key)와 그에 대응하는 값(Value)을 연결하여 데이터를 저장하는 자료형

   - 하나의 키는 하나의 데이터에만 연결

   - 키는 중복될 수 없음

   - 아이템에는 순서가 없지만 키에는 내부적으로 순서가 있으므로 for~in 구문으로 순회 탐색 가능

   - 키의 타입은 Hash 연산이 가능한 타입 즉, Hashable 프로토콜을 채택하고 구현한 타입

   <br />

   <br />

   <br />

### 옵셔널

- 값이 없음을 의미하는 특수한 값

- 언어 차원에서 프로그램의 안정성을 높이기 위해 사용

- Objc에서는 빈 메모리 주소를 가리키는 값이었지만 스위프트에서는 단순히 '값이 없음'을 의미

- 스위프트에서는 연산 과정에서 정상적으로 값을 처리하지 못하는 상황이 발생했을 때 오류 대신 nil을 반환

- 옵셔널 타입으로 선언된 자료형만 nil 값을 저장할 수 있음

- 옵셔널 타입 : 반환하고자 하는 값을 옵셔널 객체로 한번 더 감싼 형태 (옵셔널 래핑)

- 옵셔널 언래핑(Optional Unwrapping) : 옵셔널 타입을 해제하고 실제 값을 추출하는 것

<br />

#### 옵셔널 해제(Optional Unwrapping)

- 명시적 해제

   - 강제 해제

      - 옵셔널 타입의 값 뒤에 "!" 기호를 붙여주는 것, 강제 해제 연산자

      - 값이 nil인 경우 런타임 오류 발생

   - 비강제 해제

      - 옵셔널 바인딩 : if 구문 내에 조건식 대신 옵셔널 값을 일반 변수나 상수에 할당하는 구문을 사용하는 방식, guard 구문을 이용해도 옵셔널 바인딩 가능

         - if 구문을 사용한 옵셔널 바인딩 : if 구문의 코드 블럭 내에서만 해제된 값 사용 가능

         - guard 구문을 사용한 옵셔널 바인딩 : 실행 흐름 상 옵셔널 값이 해제되지 않으면 진행이 불가능할 정도로 큰일이 생길 때 사용하는 것이 좋음

- 묵시적 해제

   - 타입 어노테이션 뒤에 ? 대신 !를 붙여서 선언

   - 형식상 옵셔널로 정의해야 하지만, 실제로 사용할 때에는 절대 nil 값이 대입될 가능성이 없는 변수일 때 사용

<br />

<br />

## 함수

- 프로그램의 실행 과정 중에서 독립적으로 처리될 수 있는 부분을 분리하여 구조화한 객체

- 입력값을 받아 내부 처리 과정을 거친 후 그 결과값을 내어놓는 형태

- 일반 함수 : 프로그래밍 언어나 프레임워크 수준에서 제공하는 함수 (기본적으로 데이터의 처리나 연산 등을 수행하기 위한 목적)

- 사용자 정의 함수 : 우리가 원하는 기능을 실행해줄 함수를 직접 만들어 사용하는 함수

   ```swift
   func 함수이름(매개변수1: 타입, 매개변수2: 타입, ...) -> 반환타입 {
   	실행 내용
   	return 반환값
   }
   ```

- 인자 레이블 : 함수의 호출 시 인자값을 구분하기 위해 사용되는 레이블

- 외부 매개변수: 함수를 호출할 때 인자값에 대한 레이블 역할 및 함수의 식별자 일부로 사용

- 내부 매개변수 : 입력된 인자값을 함수 내부에서 참조하기 위해 사용되는 변수

   ```swift
   func 함수이름(<외부 매개변수명> <내부 매개변수명>: <타입>, ...) -> 반환타입 {
   	//함수 내용
   }
   ```

- 가변 인자 : 인자값의 입력 개수를 제한하지 않도록 하는 인자, ...로 표시 (함수 내부에서 배열로 처리)

   ```swift
   func 함수이름(매개변수명: 매개변수타입 ...)
   ```

- 기본값을 갖는 매개변수

   ```swift
   func 함수이름(매개변수: 매개변수타입 = 기본값)
   ```

- 스위프트에서 매개변수는 상수로 정의되기 때문에 함수 내에서 수정 불가능

   - 아래와 같이 변수화하여 수정할 수 있도록 가능

   ```swift
   func incrementBy(base: Int) -> Int {
       var base = base
       base += 1
       return base
   }
   ```

- inout 매개변수 : 함수 내부에서 수정된 인자값을 함수 외부에 전달할 수 있도록 하는 키워드

   ```swift
   func foo(paramCount: inout Int) -> Int {
       paramCount += 1
       return paramCount
   }
   ```

   - 함수 호출 시 인자값 앞에 & 연산자를 붙여주어야 한다.

   - 정확한 의미는 값이 저장된 메모리 주소를 전달한다는 의미(참조에 의한 전달)

   - 클래스는 항상 참조 전달이기 때문에 inout을 쓸 필요 없음

   - 상수, 리터럴은 inout 인자값으로 전달될 수 없음

- 스코프(Scope) : 변수의 생존 범위, 스위프트에서는 선언된 블록 내부

   - 변수가 생성된 블록이 아닌 다른 블록에서 사용하려면 반드시 초기화되어 있어야 한다

      - 하나의 블록 내에서 다른 블록으로 참조에 의한 전달 과정이 일어나기 때문이다

      - 변수가 초기화되지 않았다면 메모리를 할당받지 못한 상태이므로 주소값도 존재하지 않는다

   - 블록변 변수 검색 순서

      - 함수 내부에서 정의된 변수를 찾음

      - 함수 외부에서 정의된 변수를 찾음

      - 글로벌 범위에서 정의된 변수를 찾음

      - import 된 라이브러리 범위에서 정의된 변수를 찾음

<br />

#### 일급 객체로서의 함수

- 일급 함수의 특성

   - 객체가 런타임에도 생성이 가능해야 한다

   - 인자값으로 전달할 수 있어야 한다

   - 반환값으로 사용할 수 있어야 한다

   - 변수나 데이터 구조 안에 저장할 수 있어야 한다

   - 할당에 사용된 이름과 관계 없이 고유한 구별이 가능해야 한다

1. 변수나 상수에 함수를 대입할 수 있음

   ```swift
   func foo(base: Int) -> String {
       return "결과값은 \(base + 1)입니다"
   }
   
   let fn1 = foo(base: 5)
   ```

   - 위는 함수의 결과값을 fn1이라는 상수에 할당하는 단순한 대입 연산

   ```swift
   func foo(base: Int) -> String {
       return "결과값은 \(base + 1)입니다"
   }
   
   let fn2 = foo
   
   print(fn2(5))
   ```

   - 위 코드가 상수 fn2에 foo 함수를 대입하는 것

   - 함수 타입 : 함수의 형태를 축약한 형태로 사용 (인자 타입1, 인자 타입2, ...) → 반환 타입

   ```swift
   func boo(age: Int) -> String {
   	return "\(age)"
   }
   ```

   <br />

      - boo - 함수의 이름

      - boo(age:) - 함수의 식별자

1. 함수의 반환 타입으로 함수를 사용할 수 있음

   ```swift
   func desc() -> String {
   	return "this is desc()"
   }
   
   func pass() -> () -> String {
   	return desc
   }
   
   let p = pass()
   
   p()
   ```

   - pass의 리턴값은 () → String 타입의 함수

   - pass의 반환값으로 desc함수가 반환

   - 상수 p에 pass의 반환값을 담음 ⇒ desc 함수가 p에 담김

   - p에 함수 호출 연산자를 붙여 실행하면 desc 함수가 실행됨

1. 함수의 인자값으로 함수를 사용할 수 있음

   - 예

   ```swift
   func incr(param: Int) -> Int {
       return param + 1
   }
   
   func broker(base: Int, function fn: (Int) -> Int) -> Int {
       return fn(base)
   }
   
   broker(base: 3, function: incr) // 4
   ```

   - 콜백 함수 사용하는 예

   ```swift
   func successThrough() {
       print("연산 처리 성공")
   }
   
   func failThrough() {
       print("연산 처리 실패")
   }
   
   func divide(base: Int, success sCallBack: () -> Void, fail fCallBack: () -> Void) -> Int {
       guard base != 0 else {
           fCallBack()
           return 0
       }
       
       defer {
           sCallBack()
       }
       
       return 100 / base
   }
   
   divide(base: 3, success: successThrough, fail: failThrough)
   ```

   - defer : 함수나 메소드에서 코드의 흐름과 상관없이 가장 마지막에 실행되는 블록 

      - 작성된 위치와 순서에 상관없이 함수가 종료되기 직전에 실행

      - defer 블록을 읽기 전에 함수의 실행이 종료되는 경우 defer 블록은 실행되지 않는다

      - 하나의 함수나 메소드 내에 defer 블록을 여러 번 사용할 수 있다. 이 때에는 가장 마지막에 작성된 defer 블록부터 역순으로 실행

      - defer 블록을 중첩해서 사용할 수 있다. 이 때에는 가장 바깥쪽 defer부터 안쪽 defer 순서로 실행된다

   - 함수를 인자로 넘기는 가장 큰 목적은 함수 내부의 코드를 건드리지 않고도 외부에서 실행 흐름을 추가하기 위함

<br />

#### 함수의 중첩

- 스위프트에서는 함수를 중첩해서 작성할 수 있다

- 이렇게 작성된 함수를 **중첩 함수**라고 한다

- __내부 함수(Nested Function)__ : 함수 내에 작성된 함수

- __외부 함수(Outer Function)__ : 내부 함수를 포함하는 바깥 쪽 함수

- __내부 함수의 생명 주기(Life Cycle)__ : 외부 함수가 종료되면 내부 함수도 종료

- **함수의 은닉성 :** 내부 함수는 일반적으로 외부 함수를 거치지 않으면 접근할 수 없다 이 때문에 내부 함수는 외부의 코드로부터 차단되는 결과를 가져옴

   ```swift
   func outer(param: Int) -> (Int) -> String {
       func inner(inc: Int) -> String {
           return "\(inc)를 리턴"
       }
       
       return inner
   }
   ```

- 하지만 위처럼 외부 함수에서 내부 함수를 반환하면 외부 함수가 종료되더라도 내부 함수의 생명은 유지됨

```swift
func basic(param: Int) -> (Int) -> Int {
    let value = param + 20
    
    func append(add: Int) -> Int {
        return value + add
    }
    
    return append
}

let result = basic(param: 10) // append(10)
result(10)  // 40
```

- 위처럼 result 상수에는 append 함수가 담기고 append 함수는 외부 함수의 value 상수를 참조한다.

- result를 실행할 때에 basic 함수는 종료되어 value도 같이 사라져 오류를 발생할 것이라 예상할 수 있지만 이 코드는 문제 없이 동작하여, 40이라는 결과를 반환한다.

- 이러한 현상에 대한 원인은 **append 함수가 클로저를 갖기 때문**이다.

#### 클로저

- 소프트웨어 아키텍쳐적인 개념

   - 클로저는 두 가지로 이뤄진 객체이다. 하나는 내부 함수이며, 또 다른 하나는 내부 함수가 만들어진 주변 환경

   - 클로저는 외부 함수 내에서 내부 함수를 반환하고, 내부 함수가 외부 함수의 지역 변수나 상수를 참조할 때 만들어진다

   - 즉, 클로저란 __내부 함수와 내부 함수에 영향을 미치는 주변 환경(Context)를 모두 포함한 객체이다.__

   - 주변 환경 : 내부 함수에서 참조하는 모든 외부 변수나 상수의 값, 그리고 내부 함수에서 참조하는 다른 객체

   - 클로저는 주변 환경을 포함하지만, 주변 환경의 객체 자체를 포함하는 것이 아니라 값을 포함한다

   - 지역 변수의 값이 저장되는 것을 "값이 캡처되었다" 라고 표현한다

- 스위프트에서의 클로저

   - 일회용 함수를 작성할 수 있는 구문

   - __익명(Anonymous) 함수__ 라고 부르기도 함

   - 스위프트에서 클로저라고 부르는 객체는 대부분 다음 세 가지 경우 중 하나에 해당

      1. 전역 함수 : 이름이 있으며, 주변 환경에서 캡처할 어떤 값도 없는 클로저

      1. 중첩 함수 : 이름이 있으며 자신을 둘러싼 함수로부터 값을 캡처할 수 있는 클로저

      1. 클로저 표현식 : 이름이 없으며 주변 환경으로부터 값을 캡처할 수 있는 경량 문법으로 작성된 클로저

<br />

#### 클로저 표현식

```swift
{ (매개 변수) -> 반환 타입 in
	실행 구문
}
```

#### 트레일링 클로저(Trailing Closure)

- 함수의 마지막 인자값이 클로저일 때, 이를 인자값 형식으로 작성하는 대신 함수의 뒤에 꼬리처럼 붙일 수 있는 문법

#### @escaping

- 인자값으로 전달된 클로저를 저장해 두었다가, 나중에 다른 곳에서도 실행할 수 있도록 혀용해주는 속성

- 스위프트에서 함수의 인자값으로 전달된 클로저는 기본적으로 **탈출불가(non-escape)**의 성격을 띔

   - 함수 내에서 직접 실행을 위해서만 사용해야 한다는 의미

   - 함수 내부라 하더라도, 변수나 상수에 대입할 수 없음

   - 또한 인자값으로 전달된 클로저는 중첩된 내부 함수에서 사용할 수도 없다 

- 클로저의 기본 속성을 탈출불가하게 관리함으로써 얻는 이점

   - 컴파일러가 코드를 최적화하는 과정에서의 성능 향상 (컴파일러가 더 이상 메모리 관리 상의 지저분한 일들에 관여할 필요가 사라지기 때문)

   - 탈출불가 클로저 내에서는 self 키워드를 사용할 수 있다. 이 클로저는 해당 함수가 끝나서 리턴되기 전에 호출될 것이 명확하기 때문

<br />

#### @autoclosure

- 인자값으로 전달된 일반 구문이나 함수 등을 클로저로 래핑하는 역할

   ```swift
   func condition(stmt: @autoclosure () -> Bool) {
       if stmt() == true {
           print("결과가 참입니다.")
       } else {
           print("결과가 거짓입니다.")
       }
   }
   
   //실행 방법
   condition(stmt: (4 > 2)
   ```

- @autoclosure 속성이 인자값에 부여되면 해당 인자값은 컴파일러에 의해 클로저로 자동 래핑된다

- 함수를 실행할 때에는 {} 형식의 클로저가 아닌 () 형식의 일반값을 인자값으로 사용한다

- 인자값은 코드에 작성된 시점이 아니라 해당 클로저가 실행되는 시점에 맞춰 실행 (__지연 실행__)

<br />

<br />

### 구조체와 클래스

- **프로퍼티(Property)** : 구조체와 클래스 내부에서 정의된 변수와 상수

- __메소드(Method)__ : 구조체와 클래스 내부에서 정의된 함수

- __멤버(Member)__ : 프로퍼티와 메소드를 합한 명칭

- 공통점

   - 프로퍼티 : 변수나 상수를 사용하여 값을 저장하는 프로퍼티 정의 가능

   - 메소드 : 함수를 사용하여 기능을 제공하는 메소드 정의 가능

   - 서브스크립트 : 속성값에 접근할 수 있는 방법을 제공하는 서브스크립트 정의 가능

   - 초기화 블록 : 객체를 원하는 초기 상태로 설정해주는 초기화 블록 정의 가능

   - 확장 : 객체에 함수적 기능을 추가하는 확장(extends) 구문 사용 가능

   - 프로토콜 : 특정 형식의 함수적 표준을 제공하기 위한 프로토콜 구현 가능

- 차이점 (구조체는 할 수 없지만 클래스는 할 수 있는 것)

   - 상속 : 클래스의 특성을 다른 클래스에게 물려주는 것

   - 타입 캐스팅 : 실행 시 컴파일러가 클래스 인스턴스의 타입을 미리 파악하고 검사 가능

   - 소멸화 구문 : 인스턴스가 소멸되기 직전에 처리해야 할 구문 미리 등록 가능

   - 참조에 의한 전달 : 클래스 인스턴스는 참조 형식으로 제공

- struct와 class를 선택하기 위한 애플의 가이드라인 권장 사항

   - 연관된 간단한 값의 집합을 캡슐화하는 것이 목적일 때 구조체 사용

   - 캡슐화한 값을 참조하는 것보다 복사하는 것이 합당할 때 구조체 사용

   - 구조체에 저장된 프로퍼티가 값 타입이며 참조하는 것보다 복사하는 것이 합당할 때 구조체 사용

   - 다른 타입으로부터 상속받거나 모델의 사이즈가 그리 크지 않다면 구조체 사용

   - 해당 모델을 serialize 해서 전송가허나 파일로 저장할 경우가 발생하면 클래스 사용

   - 해당 모델이 ObjC 에서도 사용되어야 한다면 클래스 사용

   <br />

#### 프로퍼티

- 역할에 따른 분류

   - 저장 프로퍼티

      - 입력된 값을 저장하거나 저장된 값을 제공하는 역할

      - 상수 및 변수를 사용해서 정의 가능

      - 클래스와 구조체에서는 사용이 가능하지만, 열거형에서는 사용 불가

   - 연산 프로퍼티

      - 특정 연산을 통해 값을 만들어 제공하는 역할

      - 변수만 사용해서 정의 가능

      - 클래스, 구조체, 열거형에서 모두 사용 가능

- 소속에 따른 분류

   - 인스턴스 프로퍼티 : 인스턴스에 소속되는 프로퍼티

   - 타입 프로퍼티 : 클래스와 구조체 자체에 소속되어 값을 가지는 프로퍼티, 인스턴스를 생성하지 않고 클래스나 구조체 자체에 값을 저장하는 프로퍼티

   <br />

- 저장 프로퍼티

   - 클래스 내에서 선언된 변수나 상수를 부르는 이름

   - 멤버 변수 : var 키워드로 정의되는 변수형 저장 프로퍼티

   - 멤버 상수 : let 키워드로 정의되는 상수형 저장 프로퍼티

   - 지연 저장 프로퍼티 : 앞에 lazy 키워드가 붙으며 초기화를 지연시켜 프로퍼티가 호출되는 순간 초기화가 진행되는 프로퍼티

- 연산 프로퍼티

   - 실제 값을 저장했다가 반환하는 것이 아니고 다른 프로퍼티의 값을 연산 처리하여 간접적으로 값을 제공하는 프로퍼티

   - 이 때 프로퍼티의 값을 참조하기 위해 내부적으로 사용하는 구문이 get 구문

   - 읽기 전용 프로퍼티 (get-only 프로퍼티) : set구문이 없는 연산 프로퍼티

- 프로퍼티 옵저버 : 특정 프로퍼티를 관찰하고 있다가 프로퍼티의 값이 변경되면 호출되는 것

   - willSet : 프로퍼티의 값이 변경되기 직전에 호출

   - didSet : 프로퍼티의 값이 변경된 직후에 호출

- 타입 프로퍼티

   - 프로퍼티 앞에 static 키워드로 선언

   - class 키워드는 연산 프로퍼티에만 붙일 수 있는 타입 프로퍼티 키워드

   - class 키워드는 상속받은 하위 클래스에서 재정의할  수 있다

   <br />

#### 메소드

- 클래스나 구조체, 열거형과 같은 객체 내에서 함수가 선언될 경우 메소드라고 통칭

- 즉, 특정 타입의 객체 내부에서 사용하는 함수

- 인스턴스 메소드 : 인스터스를 생성한 후에 호출할 수 있는 메소드

   - 인스턴스 프로퍼티에 접근하거나 수정하는 방법을 제공하거나 인스턴스의 생성 목적에 따른 함수적 관계성을 제공하는 등 객체의 인스턴스에 대한 기능적 측면 제공

   - 구조체와 클래스의 인스턴스에 소속

   - 메소드 내에서 정의된 변수와 상수 뿐만 아니라 클래스 범위에서 정의된 프로퍼티도 모두 참조 가능

   - self 키워드 사용 가능

   - 구조체나 열거형의 인스턴스 메소드 내부에서 프로퍼티 값을 수정할 때는  메소드 앞에 __mutating__ 키워드를 명시해야 함

- 타입 메소드 : 객체 타입에서 호출할 수 있는 메소드

#### 상속

- 한 클래스가 다른 클래스에서 정의된 프로퍼티나 메소드를 물려받아 사용하는 것

- 서브 클래싱 : 기존 클래스를 기반으로 하여 새로운 클래스를 작성하는 과정

- 오버라이딩 : 자식 클래스에서 상속받은 메소드나 프로퍼티를 재정의하는 것

   - 프로퍼티 오버라이딩 시 허용되는 것

      - 저장 프로퍼티를 get, set 구문이 모두 있는 연산 프로퍼티로 오버라이딩하는 것

      - get, set 구문이 모두 제공되는 연산 프로퍼티를 get, set 구문이 모두 제공되는 연산 프로퍼티로 오버라이딩하는 것

      - get 구문만 제공되는 연산 프로퍼티를 get, set 구문이 모두 제공되는 연산 프로퍼티로 오버라이딩하는 것

      - get 구문만 제공되는 연산 프로퍼티를 get 구문만 제공되는 연산 프로퍼티로 오버라이딩하는 것

   - 프로퍼티 오버라이딩 시 허용되지 않는 것

      - 저장 프로퍼티를 저장 프로퍼티로 오버라이딩하는 것

      - get, set 구문과 관계 없이 연산 프로퍼티를 저장 프로퍼티로 오버라이딩하는 것

      - 저장 프로퍼티를 get 구문만 제공되는 연산 프로퍼티(읽기 전용)로 오버라이딩하는 것

      - get, set 구문을 모두 제공하는 연산 프로퍼티를 get 구문만 제공되는 연산 프로퍼티로 오버라이딩하는 것

   - 즉, 프로퍼티 오버라이딩은 상위 클래스의 기능을 제한하는 것이 아닌 확장, 변경하는 방식으로 진행되어야한다는 것

- 오버로딩 : 매개변수의 개수나, 타입, 이름 및 반환타입을 다르게 함으로써 같은 이름을 가진 메소드를 여러 개 만드는 것

- final 키워드 : 상위 클래스에서 정의한 메소드나 프로퍼티가 하위 클래스에서 오버라이딩되는 것을 차단하는 키워드, 클래스 자체에 붙이면 상속이 불가능한 클래스로 생성

- 타입 캐스팅 : 자식 클래스를 본래의 타입 대신 부모 클래스 타입으로 선언하여 사용하는 것

- 타입 비교 연산 : is 

   - 연산자 왼쪽 인스턴스의 타입이 비교대상 타입과 일치할 경우 - true

   - 연산자 왼쪽 인스턴스의 타입이 비교대상 타입의 하이 클래스일 경우 - true

   - 그 외 - false

- 타입 캐스팅 연산

   - 업 캐스팅

      - 하위 클래스 타입을 상위 클래스 타입으로 변환

      - 캐스팅한 결과, 캐스팅하기 전 타입보다 추상화될 때

      - 일반적으로 캐스팅 과정에서 오류 발생 X

      ```swift
      객체 as 변환할 타입
      ```

   - 다운 캐스팅

      - 상위 클래스 타입을 하위 클래스 타입으로 변환

      - 캐스팅한 결과, 캐스팅하기 전 타입보다 구체화될 때

      - 캐스팅 과정에서 오류 발생 가능성 있음

      - 오류에 대한 처리 방식에 따라 옵셔널 캐스팅과 강제 캐스팅으로 나뉘어짐

      ```swift
      객체 as? 변환할 타입(결과는 옵셔널 타입, 타입 캐스팅 실패시 nil 반환)
      객체 as! 변환할 타입(결과는 일반 타입, 타입 캐스팅 실패시 런타임 에러)
      ```

      <br />

#### Any, AnyObject

- AnyObject : 클래스의 일종으로, 모든 종류의 클래스 타입을 저장할 수 있는 범용 타입 클래스, 모든 클래스의 인스턴스는 AnyObject 클래스 타입으로 선언된 변수나 상수에 할당 가능

- Any : AnyObject와 비슷한 범용 객체이지만, 클래스에 국한되지 않고 스위프트에서 제공하는 모든 타입 허용

   - Any 타입의 남용은 스위프트에서 사용되는 정적인 타입들을 모두 동적인 타입으로 바꾸는 결과를 낳는다

   - 실행되기 전 값의 타입을 알기 어렵기 때문에 컴파일러가 오류를 잡아내지 못해 런타임 오류 발생 여지 다분

   <br />

#### 초기화 구문

- 인스턴스를 생성해 메모리 공간을 할당 받는 과정

- 멤버와이즈 초기화 구문 : 구조체 내부에 선언된 모든 저장 프로퍼티를 일괄로 외부의 값으로 초기화할 수 있는 구문

- 클래스의 경우에는 멤버와이즈 초기화 구문을 제공하지 않는다.

- init 초기화 메소드

   ```swift
   init(<매개변수>: <타입>, ...) {
   	1. 매개변수 초기화
   	2. 인스턴스 생성 시 기타 처리할 내용
   }
   ```

   1. 초기화 메소드의 이름은 init으로 통일

   1. 매개변수의 개수, 이름, 타입은 임의로 정의 가능

   1. 오버로딩 가능

   1. 정의된 초기화 메소드는 직접 호출되기도 하지만, 대부분 인스턴스 생성 시 간접적으로 호출

   - init 메소드를 정의하면 기본 초기화 구문은 제공되지 않는다.

   - init 메소드를 정의한 후 기본 초기화 구문을 사용하려면 직접 init() 메소드를 정의해야 함

   - 초기화 구문 델리게이션(Initializer Delegation) : 연쇄적으로 오버라이딩된 자식 클래스의 초기화 구문에서 부모 클래스의 초기화 구문에 대한 호출이 발생하는 것

   - 부모 클래스에서 기본 초기화 구문 외에 다른 형식의 초기화 구문이 추가되어 있다면, 자식 클래스에서 기본 초기화 구문을 오버라이딩할 때 명시적으로 부모 클래스의 기본 초기화 구문을 호출해야 한다

   <br />

#### 옵셔널 체인

- 옵셔널 연산자를 이용하여 옵셔널 속성을 연결해서 처리하는 것

- 객체가 nil인 상황에서 안정성 검사를 하지 않고 메소드나프로퍼티를 호출하더라도 오류를 발생하지 않음

- 옵셔널 체인으로 참조된 값은 무조건 옵셔널 타입으로 반환

   - 옵셔널 체인이라는 구문 자체가 nil을 반환할 가능성을 내포하고 있기 때문

- 옵셔널 체인 과정에서 옵셔널 타입들이 여러 번 겹쳐 있더라도 중첩되지 않고 한 번만 처리

   - startup?.ceo?.name ≠ Optional(Optional("대표")) 

   - startup?.ceo?.name == Optional("대표")

   <br />

